<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Genealogy Filename Generator</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.3.0/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/bootstrap-icons/1.11.3/font/bootstrap-icons.min.css" rel="stylesheet">
    <style>
        .suggestions {
            position: absolute;
            z-index: 1050;
            width: 100%;
            background: white;
            border: 1px solid #ced4da;
            border-radius: 0.375rem;
            margin-top: 2px;
            max-height: 200px;
            overflow-y: auto;
            box-shadow: 0 0.125rem 0.25rem rgba(0, 0, 0, 0.075);
        }

        .suggestion-item {
            padding: 0.5rem 0.75rem;
            cursor: pointer;
            border-bottom: 1px solid #f8f9fa;
            font-size: 0.875rem;
        }

        .suggestion-item:hover {
            background-color: #e9ecef;
        }

        .suggestion-item.active {
            background-color: #0d6efd;
            color: white;
        }

        .suggestion-item:last-child {
            border-bottom: none;
        }

        .command-pre {
            background-color: #212529;
            color: #20c997;
            padding: 1rem;
            border-radius: 0.375rem;
            overflow-x: auto;
            font-size: 0.875rem;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            white-space: pre-wrap;
            word-break: break-all;
            margin: 0;
        }

        .copy-command-button {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            z-index: 10;
        }

        .filename-input {
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            background-color: #f8f9fa;
        }

        .keyword-tag {
            display: inline-flex;
            align-items: center;
            background-color: #e9ecef;
            padding: 0.25rem 0.5rem;
            border-radius: 0.375rem;
            font-size: 0.875rem;
            margin: 0.125rem;
        }

        .keyword-remove {
            background: none;
            border: none;
            color: #dc3545;
            cursor: pointer;
            font-weight: bold;
            margin-left: 0.25rem;
            padding: 0;
            line-height: 1;
        }

        .upload-zone {
            border: 2px dashed #ced4da;
            border-radius: 0.375rem;
            padding: 2rem;
            text-align: center;
            background-color: #f8f9fa;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .upload-zone:hover {
            border-color: #0d6efd;
            background-color: #f0f8ff;
        }

        .upload-zone.dragover {
            border-color: #0d6efd;
            background-color: #e3f2fd;
        }

        .form-field {
            position: relative;
        }

        .hidden {
            display: none !important;
        }

        .additional-person-row {
            background-color: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 0.375rem;
            padding: 0.75rem;
            margin-bottom: 0.5rem;
            position: relative;
        }

        .gedcom-processing-container {
            background-color: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 0.375rem;
            padding: 1rem;
            margin-bottom: 1rem;
        }

        .processing-progress {
            height: 8px;
            border-radius: 4px;
            overflow: hidden;
            background-color: #e9ecef;
            margin-bottom: 0.5rem;
        }

        .processing-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #007bff 0%, #0056b3 100%);
            transition: width 0.3s ease;
            border-radius: 4px;
        }

        .processing-status {
            font-size: 0.875rem;
            color: #6c757d;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .processing-stats {
            font-size: 0.75rem;
            color: #6c757d;
            margin-top: 0.25rem;
        }

        .additional-person-row:nth-child(even) {
            background-color: #ffffff;
        }

        .remove-person-btn {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            line-height: 1;
        }

        .person-suggestions {
            position: absolute;
            z-index: 1060;
            width: calc(100% - 0.5rem);
            background: white;
            border: 1px solid #ced4da;
            border-radius: 0.375rem;
            margin-top: 2px;
            max-height: 150px;
            overflow-y: auto;
            box-shadow: 0 0.125rem 0.25rem rgba(0, 0, 0, 0.075);
        }

        /* GEDCOM Suggestion Styles */
        .gedcom-suggestions-section {
            background: linear-gradient(135deg, #f8f9ff 0%, #fff8f4 100%);
            border: 1px solid #e3e6f0;
            border-radius: 0.5rem;
            padding: 1rem;
            margin-bottom: 1rem;
        }

        .suggestion-button {
            margin: 0.25rem;
            border-radius: 1.5rem;
            font-size: 0.875rem;
            padding: 0.375rem 0.75rem;
            border: 1px solid #0d6efd;
            background-color: white;
            color: #0d6efd;
            transition: all 0.2s ease;
        }

        .suggestion-button:hover {
            background-color: #0d6efd;
            color: white;
            transform: translateY(-1px);
            box-shadow: 0 0.25rem 0.5rem rgba(13, 110, 253, 0.25);
        }

        .suggestion-confidence {
            font-size: 0.75rem;
            opacity: 0.7;
            margin-left: 0.25rem;
        }

        .suggestion-reason {
            font-size: 0.75rem;
            color: #6c757d;
            font-style: italic;
            margin-top: 0.25rem;
        }

        .family-insights-panel {
            background: linear-gradient(135deg, #f1f8ff 0%, #fff1f8 100%);
            border: 1px solid #d1ecf1;
            border-radius: 0.5rem;
            padding: 1rem;
            margin-bottom: 1rem;
        }

        .insights-header {
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: space-between;
            font-weight: 600;
            color: #0c5460;
        }

        .insights-content {
            margin-top: 0.75rem;
            padding-top: 0.75rem;
            border-top: 1px solid #d1ecf1;
        }

        .insight-stat {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.25rem 0;
            font-size: 0.875rem;
        }

        .insight-value {
            font-weight: 500;
            color: #0c5460;
        }

        .surname-list {
            display: flex;
            flex-wrap: wrap;
            gap: 0.25rem;
            margin-top: 0.5rem;
        }

        .surname-tag {
            background-color: #cff4fc;
            color: #055160;
            padding: 0.125rem 0.5rem;
            border-radius: 0.75rem;
            font-size: 0.75rem;
            font-weight: 500;
        }

        .quality-bar {
            height: 0.5rem;
            background-color: #e9ecef;
            border-radius: 0.25rem;
            overflow: hidden;
            margin-top: 0.25rem;
        }

        .quality-fill {
            height: 100%;
            background: linear-gradient(90deg, #dc3545 0%, #ffc107 50%, #28a745 100%);
            transition: width 0.3s ease;
        }

        /* Tab Navigation Styling */
        .tab-bar {
            background-color: rgba(255, 255, 255, 0.15);
            margin: 0 -1rem;
            padding: 0 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .card-header-tabs {
            margin-bottom: 0;
            border-bottom: none;
        }

        .card-header-tabs .nav-link {
            color: rgba(255, 255, 255, 0.8);
            border: none;
            border-bottom: 2px solid transparent;
            background: transparent;
            font-weight: normal;
            transition: all 0.2s ease;
        }

        .card-header-tabs .nav-link:hover {
            color: rgba(255, 255, 255, 0.95);
            border-bottom-color: rgba(255, 255, 255, 0.6);
            background: transparent;
        }

        .card-header-tabs .nav-link.active {
            color: #ffffff;
            border-bottom-color: #ffffff;
            background: transparent;
            font-weight: bold;
        }
    </style>
</head>
<body class="bg-light">
    <div class="container-fluid py-4">
        <div class="row justify-content-center">
            <div class="col-12">
                <h1 class="text-center mb-4 fw-bold text-dark">Genealogical Research File Naming Tool</h1>
            </div>
        </div>

        <div class="row">
            <!-- Left Column - Input Fields -->
            <div class="col-lg-6 mb-4">
                <div class="card">
                    <div class="card-header bg-primary text-white">
                        <h5 class="card-title mb-0"><i class="bi bi-pencil-square me-2"></i>Event Information</h5>
                    </div>
                    <div class="card-body">
                        <!-- File Upload Section -->
                        <div class="mb-4">
                            <input type="file" accept=".ged" id="gedcom-upload" style="display: none;">
                            <label for="gedcom-upload" id="upload-zone" class="upload-zone w-100">
                                <i class="bi bi-cloud-upload display-6 text-primary mb-2"></i>
                                <div>
                                    <span id="upload-text" class="fw-semibold">Load a GEDCOM file</span>
                                    <div class="small text-muted mt-1">Load your genealogy data to enable auto-suggestions</div>
                                    <div class="small text-muted mt-2"><i class="bi bi-shield-check me-1"></i>Your data remains in your browser on your PC</div>
                                </div>
                            </label>
                            
                            <!-- GEDCOM Processing Progress -->
                            <div id="gedcom-processing-progress" class="gedcom-processing-container hidden">
                                <div class="d-flex align-items-center mb-2">
                                    <i class="bi bi-gear-fill text-primary me-2"></i>
                                    <span class="fw-semibold">Processing GEDCOM file...</span>
                                </div>
                                <div class="processing-progress">
                                    <div id="processing-progress-bar" class="processing-progress-bar" style="width: 0%"></div>
                                </div>
                                <div class="processing-status">
                                    <span id="processing-status-text">Initializing...</span>
                                    <span id="processing-percentage">0%</span>
                                </div>
                                <div id="processing-stats" class="processing-stats">
                                    <span id="processing-file-info"></span>
                                    <span id="processing-eta"></span>
                                </div>
                                <div class="mt-2">
                                    <button type="button" class="btn btn-sm btn-outline-secondary" id="cancel-processing">
                                        <i class="bi bi-x-circle me-1"></i>Cancel
                                    </button>
                                </div>
                            </div>

                            <!-- File Loaded Indicator -->
                            <div id="file-loaded-indicator" class="alert alert-success d-flex align-items-center hidden" role="alert">
                                <i class="bi bi-file-earmark-check me-2"></i>
                                <div class="flex-grow-1">
                                    <strong>GEDCOM file loaded:</strong> <span id="loaded-filename"></span>
                                    <div class="small">Auto-suggestions are now available</div>
                                </div>
                                <button type="button" class="btn btn-sm btn-outline-success ms-2" id="change-file">
                                    <i class="bi bi-arrow-repeat me-1"></i>Change file
                                </button>
                            </div>
                        </div>

                        <div class="row">
                            <!-- Event Type Field -->
                            <div class="col-md-6">
                                <div class="form-field mb-3">
                                    <label class="form-label fw-semibold">Event Type (WHAT)</label>
                                    <input type="text" id="eventType" class="form-control" placeholder="Birth, Marriage, Death, etc.">
                                    <div id="eventSuggestions" class="suggestions hidden"></div>
                                </div>
                            </div>

                            <!-- Date Field -->
                            <div class="col-md-6">
                                <div class="mb-3">
                                    <label class="form-label fw-semibold">Date (WHEN) <i class="bi bi-info-circle text-muted" data-bs-toggle="tooltip" data-bs-title="Formats: Abt 1916, Bet 1920-1925, Bfr 1850, Aft 1936, Est 1930, Cal 1925, Int 1920, or precise date" style="font-size: 0.9em; cursor: help;"></i></label>
                                    <div class="date-input-container">
                                        <input type="text" id="genealogyDate" class="form-control" placeholder="Abt 1916, Bet 1920-1925, or 1922-01-04">
                                        <div id="dateValidation" class="form-text text-danger small" style="display: none;"></div>
                                        <div class="d-flex align-items-center mt-2">
                                            <small class="text-muted me-2">Or use precise date:</small>
                                            <input type="date" id="preciseDate" class="form-control form-control-sm" style="width: auto;">
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Place Field -->
                        <div class="form-field mb-3">
                            <div class="row">
                                <div class="col-md-8">
                                    <label class="form-label fw-semibold">Place (WHERE) <i class="bi bi-info-circle text-muted" data-bs-toggle="tooltip" data-bs-title="Enter places in your preferred format (typically smallest to largest). Use commas as placeholders for unknown parts. Countries will be converted to 3-letter codes." style="font-size: 0.9em; cursor: help;"></i></label>
                                    <input type="text" id="place" class="form-control" placeholder="Wadsworth, Medina County, Ohio, USA">
                                </div>
                                <div class="col-md-4">
                                    <label class="form-label fw-semibold">Place Format</label>
                                    <select id="placeFormat" class="form-select">
                                        <option value="usa">USA (City, County, State)</option>
                                        <option value="canada">Canada (City, Region, Province)</option>
                                        <option value="uk">UK (Town, District, County)</option>
                                        <option value="germany">Germany (Stadt, Kreis, State)</option>
                                        <option value="australia">Australia (Town, Shire, State)</option>
                                        <option value="generic">Generic (City, Region2, Region1)</option>
                                    </select>
                                </div>
                            </div>
                            <div id="placeSuggestions" class="suggestions hidden"></div>
                        </div>

                        <div class="row">
                            <!-- Surname Field -->
                            <div class="col-md-4">
                                <div class="form-field mb-3">
                                    <label class="form-label fw-semibold">Surname (WHO)</label>
                                    <input type="text" id="surname" class="form-control" placeholder="DOE">
                                    <div id="surnameSuggestions" class="suggestions hidden"></div>
                                </div>
                            </div>

                            <!-- Given Name Field -->
                            <div class="col-md-4">
                                <div class="form-field mb-3">
                                    <label class="form-label fw-semibold">Given Name</label>
                                    <input type="text" id="givenName" class="form-control" placeholder="Jane">
                                    <div id="givenNameSuggestions" class="suggestions hidden"></div>
                                </div>
                            </div>

                            <!-- Middle Name Field -->
                            <div class="col-md-4">
                                <div class="mb-3">
                                    <label class="form-label fw-semibold">Middle Name</label>
                                    <input type="text" id="middleName" class="form-control" placeholder="Alma">
                                </div>
                            </div>
                        </div>

                        <!-- Additional People Section -->
                        <div class="mb-3">
                            <div class="form-check">
                                <input type="checkbox" id="includeAdditionalPeople" class="form-check-input">
                                <label for="includeAdditionalPeople" class="form-check-label fw-semibold">
                                    Include Additional People (spouse, witness, child, etc.)
                                </label>
                            </div>
                        </div>

                        <!-- Dynamic Additional People Section -->
                        <div id="additionalPeopleSection" class="hidden">
                            <div class="border-top pt-3 mb-3">
                                <!-- GEDCOM Suggestions Section -->
                                <div id="gedcomSuggestionsSection" class="gedcom-suggestions-section hidden">
                                    <div class="alert alert-info d-flex align-items-center mb-3">
                                        <i class="bi bi-lightbulb me-2"></i>
                                        <div>
                                            <strong>Smart Suggestions Available</strong>
                                            <div class="small">Based on your family tree data and document type</div>
                                        </div>
                                    </div>
                                    
                                    <div id="relationshipSuggestions" class="relationship-suggestions mb-3">
                                        <!-- Suggestion buttons will be dynamically inserted here -->
                                    </div>
                                </div>
                                
                                <!-- Relationship-Specific Suggestions Section -->
                                <div id="relationshipSpecificSuggestions" class="gedcom-suggestions-section hidden">
                                    <div class="alert alert-success d-flex align-items-center mb-3">
                                        <i class="bi bi-people me-2"></i>
                                        <div>
                                            <strong id="relationshipSuggestionsTitle">Suggested Spouses</strong>
                                            <div class="small">Click to add from your family tree</div>
                                        </div>
                                    </div>
                                    
                                    <div id="relationshipFilteredSuggestions" class="relationship-suggestions mb-3">
                                        <!-- Relationship-filtered suggestion buttons will be dynamically inserted here -->
                                    </div>
                                </div>
                                
                                <!-- Add Person Button -->
                                <div class="text-center mb-3">
                                    <button type="button" id="addPersonBtn" class="btn btn-outline-primary btn-sm">
                                        <i class="bi bi-person-plus me-1"></i>Add Person
                                    </button>
                                </div>
                                
                                <!-- Dynamic People Container -->
                                <div id="dynamicPeopleContainer">
                                    <!-- Dynamic person rows will be inserted here -->
                                </div>
                                
                                <!-- GEDCOM Family Tree Insights Panel -->
                                <div id="familyInsightsPanel" class="family-insights-panel hidden">
                                    <div class="insights-header" id="insightsToggle">
                                        <span>
                                            <i class="bi bi-diagram-3 me-2"></i>
                                            Family Tree Overview
                                        </span>
                                        <i class="bi bi-chevron-down" id="insightsChevron"></i>
                                    </div>
                                    <div class="insights-content hidden" id="insightsContent">
                                        <div class="row">
                                            <div class="col-md-6">
                                                <div class="insight-stat">
                                                    <span>Total Individuals:</span>
                                                    <span class="insight-value" id="totalIndividuals">-</span>
                                                </div>
                                                <div class="insight-stat">
                                                    <span>Named Individuals:</span>
                                                    <span class="insight-value" id="namedIndividuals">-</span>
                                                </div>
                                                <div class="insight-stat">
                                                    <span>Date Range:</span>
                                                    <span class="insight-value" id="dateRangeValue">-</span>
                                                </div>
                                                <div class="insight-stat">
                                                    <span>Relationships:</span>
                                                    <span class="insight-value" id="relationshipCoverage">-</span>
                                                </div>
                                            </div>
                                            <div class="col-md-6">
                                                <div>
                                                    <span class="fw-semibold">Data Quality Score:</span>
                                                    <div class="quality-bar">
                                                        <div class="quality-fill" id="qualityFill" style="width: 0%"></div>
                                                    </div>
                                                    <div class="small text-muted mt-1" id="qualityScore">0% complete</div>
                                                </div>
                                                <div class="mt-3">
                                                    <span class="fw-semibold">Common Surnames:</span>
                                                    <div class="surname-list" id="surnameList">
                                                        <!-- Surname tags will be inserted here -->
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                        
                                        <div class="mt-3 pt-3 border-top">
                                            <div class="small text-muted">
                                                <i class="bi bi-info-circle me-1"></i>
                                                This data is analyzed from your uploaded GEDCOM file to provide intelligent suggestions.
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- File Info Field -->
                        <div class="form-field mb-3">
                            <label class="form-label fw-semibold">File Info (Additional) <i class="bi bi-info-circle text-muted" data-bs-toggle="tooltip" data-bs-title="Additional document type or description information (e.g., Birth-Certificate, Marriage-License, Death-Record)" style="font-size: 0.9em; cursor: help;"></i></label>
                            <input type="text" id="fileInfo" class="form-control" placeholder="Birth-Certificate, Marriage-License, Death-Record, etc.">
                            <div id="fileInfoSuggestions" class="suggestions hidden"></div>
                        </div>

                        <!-- Clear Button -->
                        <div class="text-center mt-4">
                            <button id="clearForm" class="btn btn-outline-danger">
                                <i class="bi bi-x-circle me-2"></i>Clear Form
                            </button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Right Column - Generated Output & Settings -->
            <div class="col-lg-6 mb-4">
                <!-- Generated Output Card -->
                <div class="card h-100" id="output-card">
                    <div class="card-header bg-success text-white">
                        <div class="d-flex justify-content-between align-items-center">
                            <h5 class="card-title mb-0"><i class="bi bi-file-earmark-text me-2"></i>Generated Output</h5>
                            <button id="toggleSettings" class="btn btn-sm btn-outline-light" type="button">
                                <i class="bi bi-gear"></i>
                            </button>
                        </div>
                    </div>
                    <div class="card-body">
                        <!-- Generated Filename -->
                        <div class="mb-4">
                            <div class="d-flex justify-content-between align-items-center mb-2">
                                <label class="form-label fw-semibold mb-0">Generated Filename:</label>
                                <button id="toggleReference" class="btn btn-sm btn-outline-secondary">
                                    <i class="bi bi-info-circle me-1"></i>Reference <i class="bi bi-chevron-down"></i>
                                </button>
                            </div>
                            <div class="input-group">
                                <input type="text" id="generatedFilename" class="form-control filename-input" readonly>
                                <button id="copyFilename" class="btn btn-outline-primary">
                                    <i class="bi bi-clipboard me-1"></i><span id="copyFilenameText">Copy</span>
                                </button>
                            </div>
                            
                            <!-- File Naming Reference Section -->
                            <div id="referenceSection" class="mt-3 hidden">
                                <div class="card border-secondary">
                                    <div class="card-header bg-light">
                                        <h6 class="card-title mb-0 text-secondary"><i class="bi bi-info-circle me-2"></i>File Naming Reference</h6>
                                    </div>
                                    <div class="card-body">
                                        <div class="mb-3">
                                            <strong>Pattern:</strong>
                                            <code class="d-block bg-light p-2 mt-1 rounded">
                                                [Type]_[Reverse.Place]_[Reverse.Date]_[SURNAME.Given.Middle]_[info].ext
                                            </code>
                                        </div>
                                        
                                        <div class="mb-3">
                                            <strong>Delimiter Usage:</strong>
                                            <ul class="mt-2 mb-0">
                                                <li><strong>Underscore ( _ )</strong> = Field separator</li>
                                                <li><strong>x</strong> = Information not known</li>
                                                <li><strong>Hyphen (-)</strong> = Sub-field separator (replaces all spaces)</li>
                                                <li><strong>Dot ( . )</strong> = Hierarchical identifier and file extension</li>
                                            </ul>
                                        </div>
                                        
                                        <div class="mb-3">
                                            <strong>Country Codes:</strong>
                                            <div class="small text-muted mt-1">
                                                Countries are automatically converted to 3-letter codes: United States→USA, Canada→CAN, England→ENG, Ireland→IRE, Scotland→SCO, Wales→WAL, Germany→GER, Australia→AUS, United Kingdom→UK
                                            </div>
                                        </div>
                                        
                                        <div class="mb-3">
                                            <strong>International Support:</strong>
                                            <div class="small text-muted mt-1">
                                                Select your country's place format from the dropdown. All formats use smallest→largest input order. Supports USA, Canada, UK, Germany, Australia, and Generic formats.
                                            </div>
                                        </div>
                                        
                                        <div>
                                            <strong>Example (USA Format):</strong>
                                            <code class="d-block bg-light p-2 mt-1 rounded">
                                                Birth_USA.Ohio.Medina-County.Wadsworth_1922.01.04_KEENER.Jane.Alma_Birth-Certificate.jpg
                                            </code>
                                            <div class="small text-muted mt-1">
                                                Input: "Wadsworth, Medina County, Ohio, USA" → Output: "USA.Ohio.Medina-County.Wadsworth". Format adapts based on selected country. Use commas as placeholders for unknown parts.
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- File Extension -->
                        <div class="mb-4">
                            <label class="form-label fw-semibold">File Extension</label>
                            <select id="fileExtension" class="form-select">
                                <option value=".jpg">.jpg</option>
                                <option value=".jpeg">.jpeg</option>
                                <option value=".tif">.tif</option>
                                <option value=".tiff">.tiff</option>
                                <option value=".png">.png</option>
                                <option value=".pdf">.pdf</option>
                                <option value=".doc">.doc</option>
                                <option value=".docx">.docx</option>
                                <option value=".xls">.xls</option>
                                <option value=".xlsx">.xlsx</option>
                                <option value=".txt">.txt</option>
                                <option value=".rtf">.rtf</option>
                                <option value=".dng">.dng</option>
                                <option value=".heic">.heic</option>
                                <option value=".webp">.webp</option>
                                <option value=".gif">.gif</option>
                                <option value=".svg">.svg</option>
                                <option value=".html">.html</option>
                            </select>
                        </div>

                        <!-- Generated EXIFtool Command -->
                        <div class="mb-3">
                            <div class="d-flex justify-content-between align-items-center mb-2">
                                <label class="form-label fw-semibold mb-0">
                                    <i class="bi bi-terminal me-1"></i>Generated EXIFtool Command:
                                </label>
                            </div>
                            <div class="position-relative">
                                <pre id="exifCommand" class="command-pre"></pre>
                                <button id="copyCommand" class="btn btn-sm btn-outline-light copy-command-button">
                                    <i class="bi bi-clipboard me-1"></i><span id="copyCommandText">Copy</span>
                                </button>
                            </div>
                        </div>

                        <!-- Command Controls -->
                        <div class="d-flex justify-content-between align-items-center flex-wrap gap-2 mb-3">
                            <div class="form-check">
                                <input type="checkbox" id="fhmwgMetadata" class="form-check-input" checked>
                                <label for="fhmwgMetadata" class="form-check-label">Include FHMWG Essential Metadata</label>
                            </div>
                            <div>
                                <a href="https://github.com/fhmwg/current-tags/blob/stage2-essentials/stage2-essentials.md" 
                                   target="_blank" class="btn btn-sm btn-link">FHMWG Reference</a>
                                <button id="toggleMetadata" class="btn btn-sm btn-outline-primary">
                                    Customize Metadata <i class="bi bi-chevron-down"></i>
                                </button>
                            </div>
                        </div>

                        <!-- EXIFtool Metadata Section -->
                        <div id="metadataSection" class="hidden">
                            <div class="border-top pt-3">
                                <h6 class="fw-semibold text-info mb-3"><i class="bi bi-tags me-2"></i>Additional Metadata Fields</h6>
                                
                                <div class="row">
                                    <!-- Title Field -->
                                    <div class="col-md-6 mb-3">
                                        <label class="form-label fw-semibold">Title</label>
                                        <input type="text" id="metaTitle" class="form-control" placeholder="Auto-generated from event and names">
                                    </div>

                                    <!-- Description Field -->
                                    <div class="col-md-6 mb-3">
                                        <label class="form-label fw-semibold">Description</label>
                                        <input type="text" id="metaDescription" class="form-control" placeholder="Brief description of the document">
                                    </div>

                                    <!-- Creator Field -->
                                    <div class="col-md-6 mb-3">
                                        <label class="form-label fw-semibold">Creator/Photographer</label>
                                        <input type="text" id="metaCreator" class="form-control" placeholder="Name of creator or photographer">
                                    </div>

                                    <!-- Copyright Field -->
                                    <div class="col-md-6 mb-3">
                                        <label class="form-label fw-semibold">Copyright</label>
                                        <input type="text" id="metaCopyright" class="form-control" placeholder="© 2025 Your Name">
                                    </div>

                                    <!-- Source Field -->
                                    <div class="col-md-6 mb-3">
                                        <label class="form-label fw-semibold">Source</label>
                                        <input type="text" id="metaSource" class="form-control" placeholder="Original source of document">
                                    </div>

                                    <!-- Repository Field -->
                                    <div class="col-md-6 mb-3">
                                        <label class="form-label fw-semibold">Repository</label>
                                        <input type="text" id="metaRepository" class="form-control" placeholder="Archive or repository name">
                                    </div>

                                    <!-- Notes Field -->
                                    <div class="col-12 mb-3">
                                        <label class="form-label fw-semibold">Research Notes</label>
                                        <textarea id="metaNotes" class="form-control" rows="3" placeholder="Additional research notes, transcription, or context"></textarea>
                                    </div>

                                    <!-- Keywords Field -->
                                    <div class="col-12 mb-3">
                                        <label class="form-label fw-semibold">Additional Keywords</label>
                                        <div class="input-group mb-2">
                                            <input type="text" id="keywordInput" class="form-control" placeholder="Add keyword and press Enter">
                                            <button id="addKeyword" class="btn btn-outline-primary">Add</button>
                                        </div>
                                        <div id="keywordsContainer" class="d-flex flex-wrap gap-1"></div>
                                    </div>
                                </div>

                                <div class="alert alert-warning" role="alert">
                                    <i class="bi bi-exclamation-triangle me-2"></i>
                                    <span id="pathWarning">Replace <strong>FILE_PATH_HERE</strong> with your directory path. The command already includes the filename at the end.</span>
                                </div>

                                <div class="card mb-3">
                                    <div class="card-header">
                                        <h6 class="card-title mb-0">Usage Tips:</h6>
                                    </div>
                                    <div class="card-body">
                                        <ul class="mb-0 small">
                                            <li>Replace FILE_PATH_HERE with a specific file or wildcard pattern (*.jpg)</li>
                                            <li>For Windows batch processing, save as .bat or .cmd file</li>
                                            <li>For Mac/Linux, save as .sh file and make executable (chmod +x filename.sh)</li>
                                            <li>Use -overwrite_original flag to avoid creating backup files</li>
                                            <li>Add -r flag for recursive processing of subdirectories</li>
                                        </ul>
                                    </div>
                                </div>

                                <div class="card">
                                    <div class="card-header">
                                        <h6 class="card-title mb-0">FHMWG Metadata Fields:</h6>
                                    </div>
                                    <div class="card-body">
                                        <div class="alert alert-info mb-3" role="alert">
                                            <small>
                                                The Family History Metadata Working Group (FHMWG) recommends these essential metadata elements:
                                                <ol class="mt-2 mb-0">
                                                    <li><strong>Title</strong> - Short name for the image (mapped from filename)</li>
                                                    <li><strong>Description</strong> - Detailed information about the image</li>
                                                    <li><strong>Date</strong> - When the depicted scene occurred (mapped from date field)</li>
                                                    <li><strong>Location</strong> - Where the scene occurred (mapped from place field)</li>
                                                    <li><strong>People</strong> - Names of individuals in the image (mapped from name fields)</li>
                                                </ol>
                                            </small>
                                        </div>
                                        
                                        <div class="row small">
                                            <div class="col-12 mb-2">
                                                <strong>Implemented:</strong>
                                                <span class="text-success">Title, Date, Location place names, Person names</span>
                                            </div>
                                            <div class="col-12 mb-2">
                                                <strong>Missing:</strong>
                                                <span class="text-danger">Location GPS coordinates, Person face tags</span>
                                            </div>
                                            <div class="col-12">
                                                <strong>Note:</strong>
                                                <span class="text-muted">Face tags require image loading. GPS coordinates could be added with map interface.</span>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Settings Card (Hidden by default) -->
                <div class="card h-100 hidden" id="settings-card">
                    <div class="card-header bg-success text-white">
                        <div class="d-flex justify-content-between align-items-center mb-2">
                            <h5 class="card-title mb-0"><i class="bi bi-gear me-2"></i>Settings</h5>
                            <button id="closeSettings" class="btn btn-sm btn-outline-light" type="button">
                                <i class="bi bi-x-lg"></i>
                            </button>
                        </div>
                        <div class="tab-bar">
                            <ul class="nav nav-tabs card-header-tabs" role="tablist">
                                <li class="nav-item" role="presentation">
                                    <button class="nav-link active" id="general-tab" data-bs-toggle="tab" data-bs-target="#general-pane" type="button" role="tab" aria-controls="general-pane" aria-selected="true">
                                        <i class="bi bi-gear me-1"></i>General
                                    </button>
                                </li>
                                <li class="nav-item" role="presentation">
                                    <button class="nav-link" id="layout-tab" data-bs-toggle="tab" data-bs-target="#layout-pane" type="button" role="tab" aria-controls="layout-pane" aria-selected="false">
                                        <i class="bi bi-file-text me-1"></i>Templates
                                    </button>
                                </li>
                            </ul>
                        </div>
                    </div>
                    <div class="card-body">
                        <div class="tab-content" id="settingsTabContent">
                            <!-- General Tab -->
                            <div class="tab-pane fade show active" id="general-pane" role="tabpanel" aria-labelledby="general-tab">
                                <!-- File Path Selection -->
                                <h6 class="mb-3"><i class="bi bi-folder me-2"></i>File Path Settings</h6>

                                <div class="mb-3">
                                    <label for="filePathInput" class="form-label fw-semibold">File Path (Optional):</label>
                                    <input type="text" id="filePathInput" class="form-control" placeholder="C:\Photos\Genealogy\ or /Users/username/Photos/Genealogy/ or leave blank for FILE_PATH_HERE">
                                    <div class="form-text">
                                        <i class="bi bi-info-circle me-1"></i>
                                        Enter the full directory path where your files are located. If left blank, "FILE_PATH_HERE" will be used as a placeholder.
                                    </div>
                                </div>
                            </div>

                            <!-- Layout Tab -->
                            <div class="tab-pane fade" id="layout-pane" role="tabpanel" aria-labelledby="layout-tab">
                                <!-- Filename Template Section -->
                                <h6 class="mb-3"><i class="bi bi-sliders me-2"></i>Filename Template</h6>

                                <!-- Help Alert with Placeholder Documentation -->
                                <div class="alert alert-info" role="alert">
                                    <strong><i class="bi bi-info-circle me-1"></i>Available Placeholders:</strong>
                                    <ul class="mb-0 mt-2 small">
                                        <li><code>{TYPE}</code> - Event type (e.g., Birth, Marriage, Death)</li>
                                        <li><code>{PLACE}</code> - Place sub-template. Define below.</li>
                                        <li><code>{DATE}</code> - Date sub-template. Define below.</li>
                                        <li><code>{NAME}</code> - Name sub-template. Define below.</li>
                                        <li><code>{SURNAME}</code> - Person's surname</li>
                                        <li><code>{GIVEN}</code> - Given name</li>
                                        <li><code>{MIDDLE}</code> - Middle name</li>
                                        <li><code>{INFO}</code> - Document type/additional info</li>
                                        <li><code>{EXT}</code> - File extension</li>
                                        <li><code>{AdditionalPeople}</code> - All additional people formatted per Additional People Name Format</li>
                                        <li><code>{{ text }}</code> - Conditional block (included only if enclosed placeholders have content)</li>
                                    </ul>
                                </div>

                                <!-- Template Input Field -->
                                <div class="mb-3">
                                    <label for="filenameTemplate" class="form-label fw-semibold">Custom Template:</label>
                                    <input type="text" id="filenameTemplate" class="form-control font-monospace" maxlength="500" placeholder="{TYPE}_{PLACE}_{DATE}_{SURNAME}.{GIVEN}.{MIDDLE}_{INFO}{EXT}">
                                    <div class="form-text">
                                        <i class="bi bi-info-circle me-1"></i>
                                        Enter your preferred filename template using the placeholders above.
                                    </div>
                                </div>

                                <!-- DATE Sub-template Section (Story 1.3) -->
                                <h6 class="mb-3 mt-4"><i class="bi bi-calendar me-2"></i>Date Sub-template</h6>

                                <div class="alert alert-info" role="alert">
                                    <strong><i class="bi bi-info-circle me-1"></i>Date Placeholder Syntax:</strong>
                                    <ul class="mb-0 mt-2 small">
                                        <li><code>{YYYY}</code> - 4-digit year (e.g., 2024)</li>
                                        <li><code>{YY}</code> - 2-digit year (e.g., 24)</li>
                                        <li><code>{MM}</code> - Zero-padded month (e.g., 03)</li>
                                        <li><code>{M}</code> - Month without padding (e.g., 3)</li>
                                        <li><code>{DD}</code> - Zero-padded day (e.g., 05)</li>
                                        <li><code>{D}</code> - Day without padding (e.g., 5)</li>
                                    </ul>
                                </div>

                                <div class="mb-3">
                                    <label for="dateSubtemplateInput" class="form-label fw-semibold">Date Sub-template:</label>
                                    <input type="text" id="dateSubtemplateInput" class="form-control font-monospace" maxlength="200" placeholder="Example: {YYYY}.{MM}.{DD}">
                                    <div class="form-text">
                                        <i class="bi bi-info-circle me-1"></i>
                                        Define how dates are formatted in your filenames. Leave blank to use default: {YYYY}.{MM}.{DD}
                                    </div>
                                </div>

                                <!-- Story 1.4: PLACE Sub-template Input -->
                                <div class="mb-3">
                                    <label for="placeSubtemplateInput" class="form-label fw-semibold">Place Sub-template:</label>
                                    <input type="text" id="placeSubtemplateInput" class="form-control font-monospace" maxlength="200" placeholder="Example: {COUNTRY}.{STATE}.{CITY}">
                                    <div class="form-text">
                                        <i class="bi bi-info-circle me-1"></i>
                                        Define how places are formatted in your filenames. Available: {COUNTRY}/{C}, {STATE}/{S}, {COUNTY}/{CO}, {CITY}/{CI}. Leave blank to use default: {COUNTRY}.{STATE}.{COUNTY}.{CITY}
                                    </div>
                                </div>

                                <!-- Story 1.5: NAME Sub-template Input -->
                                <div class="mb-3">
                                    <label for="nameSubtemplateInput" class="form-label fw-semibold">Primary Person Name Sub-template:</label>
                                    <input type="text" id="nameSubtemplateInput" class="form-control font-monospace" maxlength="200" placeholder="Example: {SURNAME:upper}.{GIVEN}">
                                    <div class="form-text">
                                        <i class="bi bi-info-circle me-1"></i>
                                        Define how the primary person's name is formatted. Available: {SURNAME}, {GIVEN}, {MIDDLE}. Leave blank to use default: {SURNAME:upper}.{GIVEN}
                                    </div>
                                </div>

                                <!-- Additional People Name Format Section -->
                                <h6 class="mb-3 mt-4"><i class="bi bi-people me-2"></i>Additional People Name Format</h6>

                                <div class="alert alert-info" role="alert">
                                    <strong><i class="bi bi-info-circle me-1"></i>Additional People Name Format Syntax:</strong>
                                    <p class="mb-2 small">Format: <code>[template]|[delimiter]</code></p>
                                    <p class="mb-2 small"><strong>Examples:</strong></p>
                                    <ul class="mb-0 small">
                                        <li><code>{GIVEN}.{SURNAME}|+</code> → Jane.Doe+Mary.Smith</li>
                                        <li><code>{SURNAME},{GIVEN}| &amp; </code> → Smith,Jane &amp; Brown,Mary</li>
                                        <li><code>{SURNAME}|; </code> → Smith; Brown</li>
                                        <li><code>{GIVEN}|, </code> → Jane, Mary</li>
                                    </ul>
                                </div>

                                <div class="mb-3">
                                    <label for="nameFormatInput" class="form-label fw-semibold">Additional People Name Format:</label>
                                    <input type="text" id="nameFormatInput" class="form-control font-monospace" maxlength="200" placeholder="{GIVEN}.{SURNAME}|+">
                                    <div class="form-text">
                                        <i class="bi bi-info-circle me-1"></i>
                                        Define how additional people names are formatted. Use {GIVEN}, {SURNAME}, {MIDDLE} placeholders. Separate format from delimiter with pipe (|).
                                    </div>
                                </div>

                                <!-- Preview Section -->
                                <div class="mb-3">
                                    <label class="form-label fw-semibold">Preview:</label>
                                    <div id="templatePreview" class="bg-light border rounded p-2 font-monospace small">
                                        Using default format
                                    </div>
                                </div>

                                <!-- Reset Button and Save Indicator -->
                                <div class="d-flex justify-content-between align-items-center">
                                    <button id="resetTemplate" class="btn btn-sm btn-outline-secondary" type="button">
                                        <i class="bi bi-arrow-counterclockwise me-1"></i>Reset to Default
                                    </button>
                                    <small id="settingsSaveIndicator" class="text-muted">
                                        <i class="bi bi-cloud-check me-1"></i>Ready
                                    </small>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>


    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.3.0/js/bootstrap.bundle.min.js"></script>
    <script>
        // Constants
        const EVENT_TYPES = [
            "Birth", "Marriage", "Death", "Census", "Baptism", "Burial", "Divorce", 
            "Adoption", "Graduation", "Retirement", "Probate", "Will", "Health", 
            "Immigration", "Emigration", "Naturalization", "Military", "Occupation", 
            "Residence", "Religion", "Education", "Genetic", "Family", "Photo", "Portrait", 
            "Name", "Height", "Weight", "Physical", "Nationality", "Property", "Social"
        ];

        const INFO_TYPES = [
            "Birth-Certificate", "Birth-Index-Record", "Delayed-Birth-Certificate", 
            "Marriage-Certificate", "Marriage-License", "Marriage-Bond", 
            "Death-Certificate", "Death-Record", "Obituary", 
            "Burial-Record", "Grave-Marker", "Headstone", 
            "Census-Record"
        ];

        // State variables
        let gedcomData = null;
        let gedcomIndividuals = [];
        let gedcomPlaces = [];
        let keywords = [];
        let activeDropdown = null;
        let activeIndex = -1;
        let additionalPeople = [];
        let personIdCounter = 1;

        // GEDCOM Processing state variables
        let isProcessingCancelled = false;
        let currentProcessingFile = null;
        let processingStartTime = null;
        let totalLines = 0;
        let processedLines = 0;
        
        // GEDCOM Relationship Intelligence
        let gedcomFamilies = [];
        let relationshipMap = new Map();
        let familyTreeStats = null;

        // Settings state variables
        const SETTINGS_STORAGE_KEY = 'genealogyFilenameSettings';
        const DEFAULT_TEMPLATE = '{TYPE}_{PLACE}_{DATE}_{SURNAME}.{GIVEN}.{MIDDLE}_{INFO}{EXT}';
        let saveSettingsTimeout = null;
        let userSettings = {
            version: '1.0',
            filenameTemplate: '',
            dateSubtemplate: '{YYYY}.{MM}.{DD}',  // Story 1.3: Default date template
            placeSubtemplate: '{COUNTRY}.{STATE}.{COUNTY}.{CITY}',  // Story 1.4: Default place template
            nameSubtemplate: '{SURNAME:upper}.{GIVEN}',  // Story 1.5: Default name template
            nameFormat: '{GIVEN}.{SURNAME}|+',
            useCustomTemplate: false,
            lastUpdated: null
        };

        // Get DOM elements
        const elements = {
            upload: document.getElementById('gedcom-upload'),
            uploadZone: document.getElementById('upload-zone'),
            uploadText: document.getElementById('upload-text'),
            fileLoadedIndicator: document.getElementById('file-loaded-indicator'),
            loadedFilename: document.getElementById('loaded-filename'),
            changeFile: document.getElementById('change-file'),
            // GEDCOM processing UI elements
            gedcomProcessingProgress: document.getElementById('gedcom-processing-progress'),
            processingProgressBar: document.getElementById('processing-progress-bar'),
            processingStatusText: document.getElementById('processing-status-text'),
            processingPercentage: document.getElementById('processing-percentage'),
            processingFileInfo: document.getElementById('processing-file-info'),
            processingEta: document.getElementById('processing-eta'),
            cancelProcessing: document.getElementById('cancel-processing'),
            eventType: document.getElementById('eventType'),
            place: document.getElementById('place'),
            placeFormat: document.getElementById('placeFormat'),
            // Removed legacy date element - now using genealogyDate and preciseDate
            genealogyDate: document.getElementById('genealogyDate'),
            preciseDate: document.getElementById('preciseDate'),
            dateValidation: document.getElementById('dateValidation'),
            surname: document.getElementById('surname'),
            givenName: document.getElementById('givenName'),
            middleName: document.getElementById('middleName'),
            fileExtension: document.getElementById('fileExtension'),
            fileInfo: document.getElementById('fileInfo'),
            generatedFilename: document.getElementById('generatedFilename'),
            filePath: document.getElementById('filePathInput'),
            exifCommand: document.getElementById('exifCommand'),
            fhmwgMetadata: document.getElementById('fhmwgMetadata'),
            metadataSection: document.getElementById('metadataSection'),
            toggleMetadata: document.getElementById('toggleMetadata'),
            referenceSection: document.getElementById('referenceSection'),
            toggleReference: document.getElementById('toggleReference'),
            clearForm: document.getElementById('clearForm'),
            copyFilename: document.getElementById('copyFilename'),
            copyCommand: document.getElementById('copyCommand'),
            keywordInput: document.getElementById('keywordInput'),
            addKeyword: document.getElementById('addKeyword'),
            keywordsContainer: document.getElementById('keywordsContainer'),
            metaTitle: document.getElementById('metaTitle'),
            metaDescription: document.getElementById('metaDescription'),
            metaCreator: document.getElementById('metaCreator'),
            metaCopyright: document.getElementById('metaCopyright'),
            metaSource: document.getElementById('metaSource'),
            metaRepository: document.getElementById('metaRepository'),
            metaNotes: document.getElementById('metaNotes'),
            // Additional people elements
            includeAdditionalPeople: document.getElementById('includeAdditionalPeople'),
            additionalPeopleSection: document.getElementById('additionalPeopleSection'),
            addPersonBtn: document.getElementById('addPersonBtn'),
            dynamicPeopleContainer: document.getElementById('dynamicPeopleContainer'),
            // GEDCOM suggestion elements
            gedcomSuggestionsSection: document.getElementById('gedcomSuggestionsSection'),
            relationshipSuggestions: document.getElementById('relationshipSuggestions'),
            relationshipSpecificSuggestions: document.getElementById('relationshipSpecificSuggestions'),
            relationshipSuggestionsTitle: document.getElementById('relationshipSuggestionsTitle'),
            relationshipFilteredSuggestions: document.getElementById('relationshipFilteredSuggestions'),
            // Family insights elements
            familyInsightsPanel: document.getElementById('familyInsightsPanel'),
            insightsToggle: document.getElementById('insightsToggle'),
            insightsContent: document.getElementById('insightsContent'),
            insightsChevron: document.getElementById('insightsChevron'),
            totalIndividuals: document.getElementById('totalIndividuals'),
            namedIndividuals: document.getElementById('namedIndividuals'),
            dateRangeValue: document.getElementById('dateRangeValue'),
            relationshipCoverage: document.getElementById('relationshipCoverage'),
            qualityFill: document.getElementById('qualityFill'),
            qualityScore: document.getElementById('qualityScore'),
            surnameList: document.getElementById('surnameList'),
            toggleSettings: document.getElementById('toggleSettings'),
            closeSettings: document.getElementById('closeSettings'),
            outputCard: document.getElementById('output-card'),
            settingsCard: document.getElementById('settings-card'),
            // Settings tab elements
            filenameTemplate: document.getElementById('filenameTemplate'),
            dateSubtemplateInput: document.getElementById('dateSubtemplateInput'),  // Story 1.3: DATE sub-template input
            placeSubtemplateInput: document.getElementById('placeSubtemplateInput'),  // Story 1.4: PLACE sub-template input
            nameSubtemplateInput: document.getElementById('nameSubtemplateInput'),  // Story 1.5: NAME sub-template input
            nameFormatInput: document.getElementById('nameFormatInput'),
            templatePreview: document.getElementById('templatePreview'),
            resetTemplate: document.getElementById('resetTemplate'),
            settingsSaveIndicator: document.getElementById('settingsSaveIndicator'),
            layoutTab: document.getElementById('layout-tab')
        };

        // Suggestion elements
        const suggestions = {
            event: document.getElementById('eventSuggestions'),
            place: document.getElementById('placeSuggestions'),
            surname: document.getElementById('surnameSuggestions'),
            givenName: document.getElementById('givenNameSuggestions'),
            fileInfo: document.getElementById('fileInfoSuggestions'),
            surname2: document.getElementById('surname2Suggestions'),
            givenName2: document.getElementById('givenName2Suggestions'),
            surname3: document.getElementById('surname3Suggestions'),
            givenName3: document.getElementById('givenName3Suggestions')
        };

        // Settings toggle handler
        elements.toggleSettings.addEventListener('click', function() {
            // Hide Output card, show Settings card
            elements.outputCard.classList.add('hidden');
            elements.settingsCard.classList.remove('hidden');
            // Update template preview with current form values
            updateTemplatePreview();
        });

        elements.closeSettings.addEventListener('click', function() {
            // Update template preview with final values before closing settings
            updateTemplatePreview();
            // Hide Settings card, show Output card
            elements.settingsCard.classList.add('hidden');
            elements.outputCard.classList.remove('hidden');
        });

        // Settings event listeners (Story 2)
        elements.filenameTemplate.addEventListener('input', function() {
            updateTemplatePreview();
            saveSettings();
        });

        // Story 1.3: dateSubtemplate field event listener
        elements.dateSubtemplateInput.addEventListener('input', function() {
            userSettings.dateSubtemplate = this.value || '{YYYY}.{MM}.{DD}';  // Use default if empty
            generateFilename();  // Regenerate filename with new date template
            saveSettings();
        });

        // Story 1.4: placeSubtemplate field event listener
        elements.placeSubtemplateInput.addEventListener('input', function() {
            userSettings.placeSubtemplate = this.value || '{COUNTRY}.{STATE}.{COUNTY}.{CITY}';  // Use default if empty
            generateFilename();  // Regenerate filename with new place template
            saveSettings();
        });

        // Story 1.5: nameSubtemplate field event listener
        elements.nameSubtemplateInput.addEventListener('input', function() {
            userSettings.nameSubtemplate = this.value || '{SURNAME:upper}.{GIVEN}';  // Use default if empty
            generateFilename();  // Regenerate filename with new name template
            saveSettings();
        });

        // Story 4: nameFormat field event listener
        elements.nameFormatInput.addEventListener('input', function() {
            updateTemplatePreview();
            saveSettings();
        });

        elements.resetTemplate.addEventListener('click', resetTemplate);

        elements.layoutTab.addEventListener('shown.bs.tab', function() {
            updateTemplatePreview();
        });

        // File upload handler
        elements.upload.addEventListener('change', handleEnhancedFileUpload);
        elements.cancelProcessing.addEventListener('click', cancelProcessing);
        elements.changeFile.addEventListener('click', showFileUpload);

        async function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            try {
                const text = await file.text();
                parseGedcom(text);
                
                // Hide upload zone and show file loaded indicator
                elements.uploadZone.classList.add('hidden');
                elements.fileLoadedIndicator.classList.remove('hidden');
                elements.loadedFilename.textContent = file.name;
                
            } catch (error) {
                console.error("Error reading the GEDCOM file:", error);
                alert("Error reading the GEDCOM file. Please try again with a valid GEDCOM file.");
            }
        }

        function showFileUpload() {
            // Cancel any ongoing processing
            cancelProcessing();
            
            // Show upload zone and hide indicators
            elements.uploadZone.classList.remove('hidden');
            elements.fileLoadedIndicator.classList.add('hidden');
            elements.gedcomProcessingProgress.classList.add('hidden');
            
            // Reset the file input
            elements.upload.value = '';
            
            // Clear GEDCOM data
            gedcomData = null;
            gedcomIndividuals = [];
            gedcomPlaces = [];
            gedcomFamilies = [];
            relationshipMap = new Map();
            familyTreeStats = null;
            
            // Hide any open suggestions
            Object.values(suggestions).forEach(container => {
                if (container) { // Check for null elements
                    container.classList.add('hidden');
                }
            });
        }

        // Basic GEDCOM parser
        function parseGedcom(gedcomText) {
            const lines = gedcomText.split(/\r?\n/);
            const individuals = [];
            const families = [];
            const places = new Set();
            
            let currentIndividual = null;
            let currentFamily = null;
            let currentEvent = null;
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                if (!line) continue;
                
                const match = line.match(/^(\d+)\s+(@\w+@\s+)?(\w+)(\s+(.*))?$/);
                if (!match) continue;
                
                const level = parseInt(match[1]);
                const tag = match[3];
                const value = match[5] || '';
                const id = match[2] ? match[2].trim() : '';
                
                if (level === 0 && tag === 'INDI') {
                    currentIndividual = { id: id, name: {}, events: [], families: [] };
                    individuals.push(currentIndividual);
                }
                else if (level === 0 && tag === 'FAM') {
                    currentFamily = { id: id, husband: '', wife: '', children: [] };
                    families.push(currentFamily);
                } 
                else if (level === 1 && tag === 'NAME' && currentIndividual) {
                    // Parse name: GivenNames /SURNAME/ Suffix
                    const nameParts = value.split('/');
                    if (nameParts.length >= 2) {
                        const givenPart = nameParts[0].trim();
                        const surname = nameParts[1].trim();
                        const suffixPart = nameParts.length > 2 ? nameParts[2].trim() : '';
                        
                        // Split given names into first and middle
                        const givenNames = givenPart.split(/\s+/).filter(n => n.length > 0);
                        const given = givenNames.length > 0 ? givenNames[0] : '';
                        const middle = givenNames.length > 1 ? givenNames.slice(1).join(' ') : '';
                        
                        currentIndividual.name = {
                            given: given,
                            surname: surname,
                            middle: middle,
                            suffix: suffixPart
                        };
                    } else {
                        currentIndividual.name = { full: value };
                    }
                }
                // Process events
                else if (level === 1 && ['BIRT', 'DEAT', 'MARR', 'BURI', 'CENS'].includes(tag) && currentIndividual) {
                    const eventType = 
                        tag === 'BIRT' ? 'Birth' : 
                        tag === 'DEAT' ? 'Death' : 
                        tag === 'MARR' ? 'Marriage' :
                        tag === 'BURI' ? 'Burial' :
                        tag === 'CENS' ? 'Census' : tag;
                    
                    currentEvent = { type: eventType, date: '', place: '' };
                    currentIndividual.events.push(currentEvent);
                }
                // Process date and place within events
                else if (level === 2 && tag === 'DATE' && currentEvent) {
                    currentEvent.date = value;
                }
                else if (level === 2 && tag === 'PLAC' && currentEvent) {
                    currentEvent.place = value;
                    places.add(value);
                }
                // Process family relationships
                else if (level === 1 && tag === 'HUSB' && currentFamily) {
                    currentFamily.husband = value;
                }
                else if (level === 1 && tag === 'WIFE' && currentFamily) {
                    currentFamily.wife = value;
                }
                else if (level === 1 && tag === 'CHIL' && currentFamily) {
                    currentFamily.children.push(value);
                }
                else if (level === 1 && tag === 'FAMS' && currentIndividual) {
                    currentIndividual.families.push({ role: 'spouse', familyId: value });
                }
                else if (level === 1 && tag === 'FAMC' && currentIndividual) {
                    currentIndividual.families.push({ role: 'child', familyId: value });
                }
            }
            
            gedcomData = { individuals, families, places: Array.from(places) };
            gedcomIndividuals = individuals;
            gedcomFamilies = families;
            gedcomPlaces = Array.from(places);
            
            // Build relationship intelligence
            console.log('Building relationship map with', individuals.length, 'individuals and', families.length, 'families');
            buildRelationshipMap(individuals, families);
            console.log('Relationship map built, total relationships:', relationshipMap.size);
            calculateFamilyTreeStats(individuals);
        }

        // Event listeners
        elements.eventType.addEventListener('input', handleEventTypeChange);
        elements.eventType.addEventListener('focus', () => filterEventSuggestions(elements.eventType.value));
        elements.eventType.addEventListener('keydown', (e) => handleKeyDown(e, 'event', EVENT_TYPES, selectEventSuggestion));

        elements.place.addEventListener('input', handlePlaceChange);
        elements.place.addEventListener('focus', () => filterPlaceSuggestions(elements.place.value));
        elements.place.addEventListener('keydown', (e) => handleKeyDown(e, 'place', gedcomPlaces, selectPlaceSuggestion));
        elements.placeFormat.addEventListener('change', handlePlaceFormatChange);

        elements.surname.addEventListener('input', handleSurnameChange);
        elements.surname.addEventListener('focus', () => filterSurnameSuggestions(elements.surname.value));
        elements.surname.addEventListener('keydown', (e) => handleKeyDown(e, 'surname', [], selectSurnameSuggestion));

        elements.givenName.addEventListener('input', handleGivenNameChange);
        elements.givenName.addEventListener('focus', () => filterGivenNameSuggestions(elements.givenName.value));
        elements.givenName.addEventListener('keydown', (e) => handleKeyDown(e, 'givenName', [], selectGivenNameSuggestion));

        elements.fileInfo.addEventListener('input', handleFileInfoChange);
        elements.fileInfo.addEventListener('focus', () => filterInfoSuggestions(elements.fileInfo.value));
        elements.fileInfo.addEventListener('keydown', (e) => handleKeyDown(e, 'fileInfo', INFO_TYPES, selectInfoSuggestion));

        // Legacy date element removed - now using genealogyDate and preciseDate event listeners
        
        // New genealogical date event listeners
        elements.genealogyDate.addEventListener('input', handleGenealogyDateInput);
        elements.preciseDate.addEventListener('input', handlePreciseDateInput);
        
        elements.middleName.addEventListener('input', generateFilename);
        elements.fileExtension.addEventListener('change', generateFilename);
        elements.filePath.addEventListener('input', function() {
            generateExifCommand();
            saveSettings();
        });

        // Additional people event listeners
        elements.includeAdditionalPeople.addEventListener('change', toggleAdditionalPeopleSection);
        elements.addPersonBtn.addEventListener('click', addPerson);

        elements.fhmwgMetadata.addEventListener('change', generateExifCommand);
        elements.metaTitle.addEventListener('input', generateExifCommand);
        elements.metaDescription.addEventListener('input', generateExifCommand);
        elements.metaCreator.addEventListener('input', generateExifCommand);
        elements.metaCopyright.addEventListener('input', generateExifCommand);
        elements.metaSource.addEventListener('input', generateExifCommand);
        elements.metaRepository.addEventListener('input', generateExifCommand);
        elements.metaNotes.addEventListener('input', generateExifCommand);

        elements.toggleMetadata.addEventListener('click', toggleMetadataSection);
        elements.toggleReference.addEventListener('click', toggleReferenceSection);
        elements.clearForm.addEventListener('click', clearForm);
        elements.copyFilename.addEventListener('click', copyFilename);
        elements.copyCommand.addEventListener('click', copyCommand);
        elements.addKeyword.addEventListener('click', addKeyword);
        elements.keywordInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                addKeyword();
            }
        });

        // Input handlers
        function handleEventTypeChange(e) {
            filterEventSuggestions(e.target.value);
            generateFilename();
        }

        function handlePlaceChange(e) {
            filterPlaceSuggestions(e.target.value);
            generateFilename();
        }

        function handlePlaceFormatChange(e) {
            updatePlaceFormatUI();
            generateFilename();
        }

        function updatePlaceFormatUI() {
            const selectedFormat = elements.placeFormat.value;
            const format = placeFormats[selectedFormat];

            if (format) {
                elements.place.placeholder = format.placeholder;
            }
        }

        function handleSurnameChange(e) {
            filterSurnameSuggestions(e.target.value);
            // Don't clear given name and middle name when typing in surname
            // This allows users to mix manual typing with dropdown selections
            generateFilename();
        }

        function handleGivenNameChange(e) {
            filterGivenNameSuggestions(e.target.value);
            generateFilename();
        }

        function handleFileInfoChange(e) {
            filterInfoSuggestions(e.target.value);
            generateFilename();
        }

        // Additional people input handlers
        function toggleAdditionalPeopleSection() {
            if (elements.includeAdditionalPeople.checked) {
                elements.additionalPeopleSection.classList.remove('hidden');
            } else {
                elements.additionalPeopleSection.classList.add('hidden');
                // Clear all additional people
                clearAllAdditionalPeople();
            }
            generateFilename();
        }

        // Dynamic People Management Functions
        function addPerson() {
            console.log('addPerson function called!');
            const personId = ++personIdCounter;
            const personData = {
                id: personId,
                relationship: 'spouse',
                surname: '',
                givenName: '',
                middleName: ''
            };
            
            additionalPeople.push(personData);
            renderPersonRow(personData);
            generateFilename();
            
            // Trigger relationship-specific suggestions for the new person
            console.log('About to call updateRelationshipSpecificSuggestions from addPerson');
            setTimeout(() => {
                console.log('Timeout fired, calling updateRelationshipSpecificSuggestions');
                updateRelationshipSpecificSuggestions();
            }, 100);
        }

        function removePerson(personId) {
            // Remove from data array
            additionalPeople = additionalPeople.filter(p => p.id !== personId);
            
            // Remove from DOM
            const personRow = document.querySelector(`[data-person-id="${personId}"]`);
            if (personRow) {
                personRow.remove();
            }
            
            generateFilename();
            
            // Update relationship-specific suggestions
            setTimeout(() => {
                updateRelationshipSpecificSuggestions();
            }, 100);
        }

        function clearAllAdditionalPeople() {
            additionalPeople = [];
            elements.dynamicPeopleContainer.innerHTML = '';
            generateFilename();
        }

        function renderPersonRow(personData) {
            const container = elements.dynamicPeopleContainer;
            
            const personRow = document.createElement('div');
            personRow.className = 'additional-person-row';
            personRow.setAttribute('data-person-id', personData.id);
            
            personRow.innerHTML = `
                <div class="row g-2 align-items-center">
                    <div class="col-3 col-md-2">
                        <select class="form-select form-select-sm person-relationship" data-field="relationship">
                            <option value="spouse" ${personData.relationship === 'spouse' ? 'selected' : ''}>Spouse</option>
                            <option value="child" ${personData.relationship === 'child' ? 'selected' : ''}>Child</option>
                            <option value="parent" ${personData.relationship === 'parent' ? 'selected' : ''}>Parent</option>
                            <option value="sibling" ${personData.relationship === 'sibling' ? 'selected' : ''}>Sibling</option>
                            <option value="witness" ${personData.relationship === 'witness' ? 'selected' : ''}>Witness</option>
                            <option value="other" ${personData.relationship === 'other' ? 'selected' : ''}>Other</option>
                        </select>
                    </div>
                    <div class="col-3 col-md-3 form-field">
                        <input type="text" class="form-control form-control-sm person-surname" 
                               placeholder="Surname" value="${personData.surname}" data-field="surname">
                        <div class="person-suggestions hidden"></div>
                    </div>
                    <div class="col-3 col-md-3 form-field">
                        <input type="text" class="form-control form-control-sm person-given" 
                               placeholder="Given" value="${personData.givenName}" data-field="givenName">
                        <div class="person-suggestions hidden"></div>
                    </div>
                    <div class="col-2 col-md-3">
                        <input type="text" class="form-control form-control-sm person-middle" 
                               placeholder="Middle" value="${personData.middleName}" data-field="middleName">
                    </div>
                    <div class="col-1">
                        <button type="button" class="btn btn-outline-danger btn-sm remove-person-btn" 
                                data-person-id="${personData.id}">×</button>
                    </div>
                </div>
            `;
            
            container.appendChild(personRow);
            attachPersonEventListeners(personRow, personData);
        }

        function attachPersonEventListeners(personRow, personData) {
            const personId = personData.id;
            
            // Remove button
            const removeBtn = personRow.querySelector('.remove-person-btn');
            removeBtn.addEventListener('click', () => removePerson(personId));
            
            // Field updates
            const relationshipSelect = personRow.querySelector('.person-relationship');
            const surnameInput = personRow.querySelector('.person-surname');
            const givenInput = personRow.querySelector('.person-given');
            const middleInput = personRow.querySelector('.person-middle');
            
            relationshipSelect.addEventListener('change', (e) => {
                updatePersonData(personId, 'relationship', e.target.value);
                // Trigger relationship-specific suggestions
                setTimeout(() => {
                    updateRelationshipSpecificSuggestions();
                }, 100);
            });
            
            surnameInput.addEventListener('input', (e) => {
                updatePersonData(personId, 'surname', e.target.value);
                // Clear related fields when surname changes
                updatePersonData(personId, 'givenName', '');
                updatePersonData(personId, 'middleName', '');
                givenInput.value = '';
                middleInput.value = '';
                // Filter surname suggestions
                filterDynamicSurnameSuggestions(e.target, personId);
            });
            
            surnameInput.addEventListener('focus', () => {
                filterDynamicSurnameSuggestions(surnameInput, personId);
            });
            
            surnameInput.addEventListener('keydown', (e) => {
                handleDynamicKeyDown(e, surnameInput, personId, 'surname');
            });
            
            givenInput.addEventListener('input', (e) => {
                updatePersonData(personId, 'givenName', e.target.value);
                filterDynamicGivenNameSuggestions(e.target, personId);
            });
            
            givenInput.addEventListener('focus', () => {
                filterDynamicGivenNameSuggestions(givenInput, personId);
            });
            
            givenInput.addEventListener('keydown', (e) => {
                handleDynamicKeyDown(e, givenInput, personId, 'givenName');
            });
            
            middleInput.addEventListener('input', (e) => {
                updatePersonData(personId, 'middleName', e.target.value);
            });
        }

        function updatePersonData(personId, field, value) {
            const person = additionalPeople.find(p => p.id === personId);
            if (person) {
                person[field] = value;
                generateFilename();
            }
        }

        // Dynamic GEDCOM suggestion functions
        function filterDynamicSurnameSuggestions(inputElement, personId) {
            const input = inputElement.value;
            const surnames = gedcomIndividuals
                .map(individual => individual.name.surname)
                .filter(Boolean)
                .filter((surname, index, self) => self.indexOf(surname) === index)
                .filter(surname => surname.toLowerCase().includes(input.toLowerCase()))
                .sort((a, b) => a.localeCompare(b));
            
            const suggestionContainer = inputElement.parentElement.querySelector('.person-suggestions');
            showDynamicSuggestions(suggestionContainer, surnames, (selected) => {
                selectDynamicSurnameChoice(inputElement, personId, selected);
            });
        }

        function filterDynamicGivenNameSuggestions(inputElement, personId) {
            const input = inputElement.value;
            const person = additionalPeople.find(p => p.id === personId);
            const surname = person ? person.surname : '';
            
            const givenNames = gedcomIndividuals
                .filter(individual => !surname || individual.name.surname === surname)
                .map(individual => individual.name.given)
                .filter(Boolean)
                .filter((name, index, self) => self.indexOf(name) === index)
                .filter(name => name.toLowerCase().includes(input.toLowerCase()))
                .sort((a, b) => a.localeCompare(b));
            
            const suggestionContainer = inputElement.parentElement.querySelector('.person-suggestions');
            showDynamicSuggestions(suggestionContainer, givenNames, (selected) => {
                selectDynamicGivenNameChoice(inputElement, personId, selected);
            });
        }

        function showDynamicSuggestions(container, suggestionList, onSelect) {
            container.innerHTML = '';
            
            if (suggestionList.length === 0) {
                container.classList.add('hidden');
                return;
            }
            
            suggestionList.forEach((suggestion, index) => {
                const item = document.createElement('div');
                item.className = 'suggestion-item';
                item.textContent = suggestion;
                item.setAttribute('data-index', index);
                item.addEventListener('click', () => {
                    onSelect(suggestion);
                });
                container.appendChild(item);
            });
            
            container.classList.remove('hidden');
        }

        // Keyboard navigation for dynamic suggestions
        function handleDynamicKeyDown(e, inputElement, personId, fieldType) {
            const suggestionContainer = inputElement.parentElement.querySelector('.person-suggestions');
            if (!suggestionContainer || suggestionContainer.classList.contains('hidden')) return;
            
            const items = suggestionContainer.querySelectorAll('.suggestion-item');
            if (items.length === 0) return;
            
            let currentActiveIndex = -1;
            const activeItem = suggestionContainer.querySelector('.suggestion-item.active');
            if (activeItem) {
                currentActiveIndex = parseInt(activeItem.getAttribute('data-index'));
            }
            
            switch (e.key) {
                case 'ArrowDown':
                    e.preventDefault();
                    currentActiveIndex = currentActiveIndex < items.length - 1 ? currentActiveIndex + 1 : 0;
                    updateDynamicActiveItem(items, currentActiveIndex);
                    break;
                    
                case 'ArrowUp':
                    e.preventDefault();
                    currentActiveIndex = currentActiveIndex > 0 ? currentActiveIndex - 1 : items.length - 1;
                    updateDynamicActiveItem(items, currentActiveIndex);
                    break;
                    
                case 'Enter':
                    e.preventDefault();
                    if (currentActiveIndex >= 0 && currentActiveIndex < items.length) {
                        const selectedText = items[currentActiveIndex].textContent;
                        if (fieldType === 'surname') {
                            selectDynamicSurnameChoice(inputElement, personId, selectedText);
                        } else if (fieldType === 'givenName') {
                            selectDynamicGivenNameChoice(inputElement, personId, selectedText);
                        }
                    }
                    break;
                    
                case 'Escape':
                    e.preventDefault();
                    suggestionContainer.classList.add('hidden');
                    updateDynamicActiveItem(items, -1);
                    break;
                    
                case 'Tab':
                    // Allow tab to close suggestions
                    suggestionContainer.classList.add('hidden');
                    updateDynamicActiveItem(items, -1);
                    break;
            }
        }

        function updateDynamicActiveItem(items, activeIndex) {
            items.forEach((item, index) => {
                if (index === activeIndex) {
                    item.classList.add('active');
                } else {
                    item.classList.remove('active');
                }
            });
        }

        function selectDynamicSurnameChoice(inputElement, personId, selectedText) {
            inputElement.value = selectedText;
            updatePersonData(personId, 'surname', selectedText);
            
            // Clear other fields when surname changes
            const personRow = inputElement.closest('[data-person-id]');
            const givenInput = personRow.querySelector('.person-given');
            const middleInput = personRow.querySelector('.person-middle');
            givenInput.value = '';
            middleInput.value = '';
            updatePersonData(personId, 'givenName', '');
            updatePersonData(personId, 'middleName', '');
            
            // Hide suggestions
            const suggestionContainer = inputElement.parentElement.querySelector('.person-suggestions');
            suggestionContainer.classList.add('hidden');
        }

        function selectDynamicGivenNameChoice(inputElement, personId, selectedText) {
            const person = additionalPeople.find(p => p.id === personId);
            const surname = person ? person.surname : '';
            
            const nameParts = selectedText.trim().split(/\s+/);
            if (nameParts.length > 1) {
                inputElement.value = nameParts[0];
                updatePersonData(personId, 'givenName', nameParts[0]);
                
                const middleInput = inputElement.closest('[data-person-id]').querySelector('.person-middle');
                middleInput.value = nameParts.slice(1).join(' ');
                updatePersonData(personId, 'middleName', nameParts.slice(1).join(' '));
            } else {
                inputElement.value = selectedText;
                updatePersonData(personId, 'givenName', selectedText);
                
                // Try to find matching individual for middle name
                const matchingIndividual = gedcomIndividuals.find(
                    individual => 
                        individual.name.surname === surname && 
                        individual.name.given === selectedText
                );
                
                if (matchingIndividual && matchingIndividual.name.middle) {
                    const middleInput = inputElement.closest('[data-person-id]').querySelector('.person-middle');
                    middleInput.value = matchingIndividual.name.middle;
                    updatePersonData(personId, 'middleName', matchingIndividual.name.middle);
                }
            }
            
            // Hide suggestions
            const suggestionContainer = inputElement.parentElement.querySelector('.person-suggestions');
            suggestionContainer.classList.add('hidden');
        }

        function toggleThirdPersonSection() {
            if (elements.includeThirdPerson.checked) {
                elements.thirdPersonSection.classList.remove('hidden');
            } else {
                elements.thirdPersonSection.classList.add('hidden');
                // Clear third person fields
                elements.surname3.value = '';
                elements.givenName3.value = '';
                elements.middleName3.value = '';
            }
            generateFilename();
        }

        function handleSurname2Change(e) {
            filterSurname2Suggestions(e.target.value);
            elements.givenName2.value = '';
            elements.middleName2.value = '';
            generateFilename();
        }

        function handleGivenName2Change(e) {
            filterGivenName2Suggestions(e.target.value);
            generateFilename();
        }

        function handleSurname3Change(e) {
            filterSurname3Suggestions(e.target.value);
            elements.givenName3.value = '';
            elements.middleName3.value = '';
            generateFilename();
        }

        function handleGivenName3Change(e) {
            filterGivenName3Suggestions(e.target.value);
            generateFilename();
        }

        // Filter functions
        function filterEventSuggestions(input) {
            const filtered = EVENT_TYPES
                .filter(type => type.toLowerCase().includes(input.toLowerCase()))
                .sort((a, b) => a.localeCompare(b));
            showSuggestions('event', filtered);
        }

        function filterPlaceSuggestions(input) {
            const filtered = gedcomPlaces
                .filter(place => place.toLowerCase().includes(input.toLowerCase()))
                .sort((a, b) => a.localeCompare(b));
            showSuggestions('place', filtered);
        }

        function filterSurnameSuggestions(input) {
            const surnames = gedcomIndividuals
                .map(individual => individual.name.surname)
                .filter(Boolean)
                .filter((surname, index, self) => self.indexOf(surname) === index)
                .filter(surname => surname.toLowerCase().includes(input.toLowerCase()))
                .sort((a, b) => a.localeCompare(b));
            showSuggestions('surname', surnames);
        }

        function filterGivenNameSuggestions(input) {
            const givenNames = gedcomIndividuals
                .filter(individual => !elements.surname.value || individual.name.surname === elements.surname.value)
                .map(individual => individual.name.given)
                .filter(Boolean)
                .filter((name, index, self) => self.indexOf(name) === index)
                .filter(name => name.toLowerCase().includes(input.toLowerCase()))
                .sort((a, b) => a.localeCompare(b));
            showSuggestions('givenName', givenNames);
        }

        function filterInfoSuggestions(input) {
            const filtered = INFO_TYPES
                .filter(type => type.toLowerCase().includes(input.toLowerCase()))
                .sort((a, b) => a.localeCompare(b));
            showSuggestions('fileInfo', filtered);
        }

        // Additional people filter functions
        function filterSurname2Suggestions(input) {
            const surnames = gedcomIndividuals
                .map(individual => individual.name.surname)
                .filter(Boolean)
                .filter((surname, index, self) => self.indexOf(surname) === index)
                .filter(surname => surname.toLowerCase().includes(input.toLowerCase()))
                .sort((a, b) => a.localeCompare(b));
            showSuggestions('surname2', surnames);
        }

        function filterGivenName2Suggestions(input) {
            const givenNames = gedcomIndividuals
                .filter(individual => !elements.surname2.value || individual.name.surname === elements.surname2.value)
                .map(individual => individual.name.given)
                .filter(Boolean)
                .filter((name, index, self) => self.indexOf(name) === index)
                .filter(name => name.toLowerCase().includes(input.toLowerCase()))
                .sort((a, b) => a.localeCompare(b));
            showSuggestions('givenName2', givenNames);
        }

        function filterSurname3Suggestions(input) {
            const surnames = gedcomIndividuals
                .map(individual => individual.name.surname)
                .filter(Boolean)
                .filter((surname, index, self) => self.indexOf(surname) === index)
                .filter(surname => surname.toLowerCase().includes(input.toLowerCase()))
                .sort((a, b) => a.localeCompare(b));
            showSuggestions('surname3', surnames);
        }

        function filterGivenName3Suggestions(input) {
            const givenNames = gedcomIndividuals
                .filter(individual => !elements.surname3.value || individual.name.surname === elements.surname3.value)
                .map(individual => individual.name.given)
                .filter(Boolean)
                .filter((name, index, self) => self.indexOf(name) === index)
                .filter(name => name.toLowerCase().includes(input.toLowerCase()))
                .sort((a, b) => a.localeCompare(b));
            showSuggestions('givenName3', givenNames);
        }

        // Show suggestions
        function showSuggestions(type, suggestionList) {
            const container = suggestions[type];
            if (!container) return;
            
            container.innerHTML = '';
            
            if (suggestionList.length === 0) {
                container.classList.add('hidden');
                return;
            }
            
            suggestionList.forEach((suggestion, index) => {
                const item = document.createElement('div');
                item.className = 'suggestion-item';
                item.textContent = suggestion;
                item.addEventListener('click', () => {
                    selectSuggestion(type, suggestion);
                });
                container.appendChild(item);
            });
            
            container.classList.remove('hidden');
        }

        // Selection functions
        function selectSuggestion(type, suggestion) {
            switch(type) {
                case 'event':
                    selectEventSuggestion(suggestion);
                    break;
                case 'place':
                    selectPlaceSuggestion(suggestion);
                    break;
                case 'surname':
                    selectSurnameSuggestion(suggestion);
                    break;
                case 'givenName':
                    selectGivenNameSuggestion(suggestion);
                    break;
                case 'fileInfo':
                    selectInfoSuggestion(suggestion);
                    break;
                case 'surname2':
                    selectSurname2Suggestion(suggestion);
                    break;
                case 'givenName2':
                    selectGivenName2Suggestion(suggestion);
                    break;
                case 'surname3':
                    selectSurname3Suggestion(suggestion);
                    break;
                case 'givenName3':
                    selectGivenName3Suggestion(suggestion);
                    break;
            }
        }

        function selectEventSuggestion(suggestion) {
            elements.eventType.value = suggestion;
            suggestions.event.classList.add('hidden');
            generateFilename();
        }

        function selectPlaceSuggestion(suggestion) {
            elements.place.value = suggestion;
            suggestions.place.classList.add('hidden');
            generateFilename();
        }

        function selectSurnameSuggestion(suggestion) {
            elements.surname.value = suggestion;
            suggestions.surname.classList.add('hidden');
            // Don't clear given name and middle name - allow mixed manual/dropdown entry
            // Only clear if the fields are empty to avoid overwriting user input
            if (!elements.givenName.value && !elements.middleName.value) {
                filterGivenNameSuggestions('');
            }
            generateFilename();
        }

        function selectGivenNameSuggestion(suggestion) {
            const nameParts = suggestion.trim().split(/\s+/);
            if (nameParts.length > 1) {
                elements.givenName.value = nameParts[0];
                elements.middleName.value = nameParts.slice(1).join(' ');
            } else {
                elements.givenName.value = suggestion;
                
                // Try to find matching individual for middle name
                const matchingIndividual = gedcomIndividuals.find(
                    individual => 
                        individual.name.surname === elements.surname.value && 
                        individual.name.given === suggestion
                );
                
                if (matchingIndividual && matchingIndividual.name.middle) {
                    elements.middleName.value = matchingIndividual.name.middle;
                }
            }
            suggestions.givenName.classList.add('hidden');
            generateFilename();
        }

        function selectInfoSuggestion(suggestion) {
            elements.fileInfo.value = suggestion;
            suggestions.fileInfo.classList.add('hidden');
            generateFilename();
        }

        // Additional people selection functions
        function selectSurname2Suggestion(suggestion) {
            elements.surname2.value = suggestion;
            suggestions.surname2.classList.add('hidden');
            elements.givenName2.value = '';
            elements.middleName2.value = '';
            filterGivenName2Suggestions('');
            generateFilename();
        }

        function selectGivenName2Suggestion(suggestion) {
            const nameParts = suggestion.trim().split(/\s+/);
            if (nameParts.length > 1) {
                elements.givenName2.value = nameParts[0];
                elements.middleName2.value = nameParts.slice(1).join(' ');
            } else {
                elements.givenName2.value = suggestion;
                
                // Try to find matching individual for middle name
                const matchingIndividual = gedcomIndividuals.find(
                    individual => 
                        individual.name.surname === elements.surname2.value && 
                        individual.name.given === suggestion
                );
                
                if (matchingIndividual && matchingIndividual.name.middle) {
                    elements.middleName2.value = matchingIndividual.name.middle;
                }
            }
            suggestions.givenName2.classList.add('hidden');
            generateFilename();
        }

        function selectSurname3Suggestion(suggestion) {
            elements.surname3.value = suggestion;
            suggestions.surname3.classList.add('hidden');
            elements.givenName3.value = '';
            elements.middleName3.value = '';
            filterGivenName3Suggestions('');
            generateFilename();
        }

        function selectGivenName3Suggestion(suggestion) {
            const nameParts = suggestion.trim().split(/\s+/);
            if (nameParts.length > 1) {
                elements.givenName3.value = nameParts[0];
                elements.middleName3.value = nameParts.slice(1).join(' ');
            } else {
                elements.givenName3.value = suggestion;
                
                // Try to find matching individual for middle name
                const matchingIndividual = gedcomIndividuals.find(
                    individual => 
                        individual.name.surname === elements.surname3.value && 
                        individual.name.given === suggestion
                );
                
                if (matchingIndividual && matchingIndividual.name.middle) {
                    elements.middleName3.value = matchingIndividual.name.middle;
                }
            }
            suggestions.givenName3.classList.add('hidden');
            generateFilename();
        }

        // Keyboard navigation
        function handleKeyDown(e, dropdownName, suggestionList, selectFunction) {
            const container = suggestions[dropdownName];
            if (!container || container.classList.contains('hidden')) return;
            
            const items = container.querySelectorAll('.suggestion-item');
            if (items.length === 0) return;
            
            switch (e.key) {
                case 'ArrowDown':
                    e.preventDefault();
                    activeIndex = activeIndex < items.length - 1 ? activeIndex + 1 : 0;
                    updateActiveItem(items);
                    break;
                    
                case 'ArrowUp':
                    e.preventDefault();
                    activeIndex = activeIndex > 0 ? activeIndex - 1 : items.length - 1;
                    updateActiveItem(items);
                    break;
                    
                case 'Enter':
                    e.preventDefault();
                    if (activeIndex >= 0 && activeIndex < items.length) {
                        selectFunction(items[activeIndex].textContent);
                        activeIndex = -1;
                    }
                    break;
                    
                case 'Escape':
                    e.preventDefault();
                    container.classList.add('hidden');
                    activeIndex = -1;
                    break;
            }
        }

        function updateActiveItem(items) {
            items.forEach((item, index) => {
                if (index === activeIndex) {
                    item.classList.add('active');
                } else {
                    item.classList.remove('active');
                }
            });
        }

        // ============================================================================
        // GENEALOGICAL DATE PROCESSING SECTION
        // ============================================================================
        
        // Parse genealogical date formats (Abt 1916, Bet 1920-1925, etc.)
        function parseGenealogyDate(dateString) {
            if (!dateString) return null;
            
            const trimmed = dateString.trim();
            
            // Standard date formats (YYYY-MM-DD, YYYY-MM, YYYY)
            if (trimmed.match(/^\d{4}(-\d{2}(-\d{2})?)?$/)) {
                return {
                    type: 'precise',
                    original: trimmed,
                    formatted: trimmed,
                    year: parseInt(trimmed.split('-')[0])
                };
            }
            
            // Genealogical date patterns
            const patterns = [
                { prefix: 'Abt', regex: /^(Abt|About)\s+(\d{4})$/i },
                { prefix: 'Bfr', regex: /^(Bfr|Before)\s+(\d{4})$/i },
                { prefix: 'Aft', regex: /^(Aft|After)\s+(\d{4})$/i },
                { prefix: 'Est', regex: /^(Est|Estimated)\s+(\d{4})$/i },
                { prefix: 'Cal', regex: /^(Cal|Calculated)\s+(\d{4})$/i },
                { prefix: 'Int', regex: /^(Int|Interpreted)\s+(\d{4})$/i },
                { prefix: 'Bet', regex: /^(Bet|Between)\s+(\d{4})-(\d{4})$/i }
            ];
            
            for (const pattern of patterns) {
                const match = trimmed.match(pattern.regex);
                if (match) {
                    if (pattern.prefix === 'Bet') {
                        return {
                            type: 'genealogical',
                            prefix: pattern.prefix,
                            original: trimmed,
                            formatted: `${pattern.prefix} ${match[2]}-${match[3]}`,
                            year: parseInt(match[2]),
                            endYear: parseInt(match[3])
                        };
                    } else {
                        return {
                            type: 'genealogical',
                            prefix: pattern.prefix,
                            original: trimmed,
                            formatted: `${pattern.prefix} ${match[2]}`,
                            year: parseInt(match[2])
                        };
                    }
                }
            }
            
            return null;
        }
        
        // Validate genealogical date format
        function validateGenealogyDate(dateString) {
            if (!dateString) return { valid: true, message: '' };
            
            const parsed = parseGenealogyDate(dateString);
            if (parsed) {
                return { valid: true, message: '', type: parsed.type };
            }
            
            // Provide helpful suggestions for common mistakes
            const trimmed = dateString.trim();
            
            if (trimmed.match(/^around\s+\d{4}/i)) {
                return { valid: false, message: 'Use "Abt 1920" instead of "Around 1920"' };
            }
            if (trimmed.match(/^circa\s+\d{4}/i)) {
                return { valid: false, message: 'Use "Abt 1920" instead of "Circa 1920"' };
            }
            if (trimmed.match(/^\d{4}\s*-\s*\d{4}$/)) {
                return { valid: false, message: 'Use "Bet 1920-1925" for date ranges' };
            }
            if (trimmed.match(/^before\s+\d{4}/i)) {
                return { valid: false, message: 'Use "Bfr 1920" instead of "Before 1920"' };
            }
            if (trimmed.match(/^after\s+\d{4}/i)) {
                return { valid: false, message: 'Use "Aft 1920" instead of "After 1920"' };
            }
            
            return { valid: false, message: 'Use formats like: Abt 1920, Bet 1920-1925, Bfr 1920, or YYYY-MM-DD' };
        }
        
        // Format genealogical date for filename (spaces to hyphens)
        function formatGenealogyDateForFilename(dateString) {
            if (!dateString || dateString.trim() === '') return 'x';
            
            const trimmed = dateString.trim();
            
            // Handle standard dates (YYYY-MM-DD format)
            if (trimmed.match(/^\d{4}-\d{2}-\d{2}$/)) {
                return trimmed.replace(/-/g, '.');
            }
            
            // Handle genealogical prefixes and convert spaces to hyphens
            return trimmed.replace(/\s+/g, '-');
        }
        
        // Format genealogical date for metadata (preserve original notation)
        function formatGenealogyDateForMetadata(dateString) {
            if (!dateString || dateString.trim() === '') return '';
            return dateString.trim(); // Return as-is for metadata
        }
        
        // Convert genealogical date to standard datetime for metadata compatibility
        function getStandardDateFromGenealogy(dateString) {
            if (!dateString || dateString.trim() === '') return '';
            
            const trimmed = dateString.trim();
            
            // If it's already in standard format, return it
            if (trimmed.match(/^\d{4}-\d{2}-\d{2}$/)) {
                return trimmed;
            }
            
            // For genealogical dates, extract year and use January 1st
            const yearMatch = trimmed.match(/(\d{4})/);
            if (yearMatch) {
                return `${yearMatch[1]}-01-01`;
            }
            
            return ''; // Cannot parse date
        }
        
        // Get current active date value (from either input)
        function getCurrentDateValue() {
            const genealogyValue = elements.genealogyDate.value.trim();
            const preciseValue = elements.preciseDate.value.trim();
            
            // Prefer genealogy input if it has content
            if (genealogyValue) {
                return genealogyValue;
            }
            
            // Use precise date if available
            if (preciseValue) {
                return preciseValue;
            }
            
            return '';
        }
        
        // Handle genealogical date input with validation and debouncing
        let dateValidationTimeout;
        function handleGenealogyDateInput() {
            const value = elements.genealogyDate.value.trim();
            
            // Clear the precise date input when typing in genealogy input
            if (value && elements.preciseDate.value) {
                elements.preciseDate.value = '';
            }
            
            // Clear previous timeout
            if (dateValidationTimeout) {
                clearTimeout(dateValidationTimeout);
            }
            
            // Debounced validation (300ms delay)
            dateValidationTimeout = setTimeout(() => {
                validateAndUpdateDateDisplay();
                generateFilename();
            }, 300);
            
            // Immediate filename generation for responsive feel
            generateFilename();
        }
        
        // Handle precise date input
        function handlePreciseDateInput() {
            const value = elements.preciseDate.value.trim();
            
            // Clear the genealogy date input when using precise date
            if (value && elements.genealogyDate.value) {
                elements.genealogyDate.value = '';
            }
            
            // Clear any validation messages
            elements.dateValidation.style.display = 'none';
            elements.genealogyDate.classList.remove('is-invalid', 'is-valid');
            
            generateFilename();
        }
        
        // Validate and update date display with visual feedback
        function validateAndUpdateDateDisplay() {
            const value = elements.genealogyDate.value.trim();
            
            if (!value) {
                // Empty input - neutral state
                elements.dateValidation.style.display = 'none';
                elements.genealogyDate.classList.remove('is-invalid', 'is-valid');
                return;
            }
            
            const validation = validateGenealogyDate(value);
            
            if (validation.valid) {
                // Valid input
                elements.genealogyDate.classList.remove('is-invalid');
                elements.genealogyDate.classList.add('is-valid');
                elements.dateValidation.style.display = 'none';
            } else {
                // Invalid input
                elements.genealogyDate.classList.remove('is-valid');
                elements.genealogyDate.classList.add('is-invalid');
                elements.dateValidation.textContent = validation.message;
                elements.dateValidation.style.display = 'block';
            }
        }
        
        // ============================================================================
        // ENHANCED GEDCOM PROCESSING SECTION
        // ============================================================================
        
        // File size thresholds for processing decisions
        const CHUNK_SIZE_LINES = 1000;
        const SMALL_FILE_THRESHOLD = 5 * 1024 * 1024; // 5MB
        const LARGE_FILE_THRESHOLD = 50 * 1024 * 1024; // 50MB
        const WARNING_FILE_THRESHOLD = 75 * 1024 * 1024; // 75MB
        
        // Enhanced file upload handler with size detection
        async function handleEnhancedFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            try {
                // Show file size warning for very large files
                if (file.size > WARNING_FILE_THRESHOLD) {
                    const fileSize = (file.size / (1024 * 1024)).toFixed(1);
                    const estimatedTime = Math.ceil(file.size / (1024 * 1024) * 2); // ~2 seconds per MB
                    
                    const confirmed = confirm(
                        `This is a large GEDCOM file (${fileSize} MB) that may take approximately ${estimatedTime} seconds to process.\n\n` +
                        `Your browser may appear unresponsive during processing, but you can cancel at any time.\n\n` +
                        `Do you want to continue?`
                    );
                    
                    if (!confirmed) {
                        event.target.value = ''; // Clear the file input
                        return;
                    }
                }
                
                // Use chunked processing for files larger than threshold
                if (file.size > SMALL_FILE_THRESHOLD) {
                    await processGedcomChunked(file);
                } else {
                    // Use original fast processing for small files
                    const text = await file.text();
                    
                    // Basic validation
                    if (!text.includes('GEDCOM') && !text.includes('INDI') && !text.includes('FAM')) {
                        throw new Error('File does not appear to be a valid GEDCOM file');
                    }
                    
                    parseGedcom(text);
                    showFileLoadedIndicator(file.name);
                }
                
            } catch (error) {
                console.error("Error processing GEDCOM file:", error);
                console.error("Error details:", error.message, error.stack);
                hideProcessingIndicator();
                alert(`Error processing the GEDCOM file: ${error.message}. Please try again with a valid GEDCOM file.`);
            }
        }
        
        // Chunked GEDCOM processing with progress tracking
        async function processGedcomChunked(file) {
            // Reset processing state
            isProcessingCancelled = false;
            currentProcessingFile = file;
            processingStartTime = Date.now();
            processedLines = 0;
            
            // Show progress indicator
            showProcessingIndicator();
            updateProcessingStatus("Reading file...", 0);
            updateFileInfo(file);
            
            try {
                // Read file in chunks for better memory management
                const text = await file.text();
                const lines = text.split(/\r?\n/);
                totalLines = lines.length;
                
                updateProcessingStatus("Processing individuals and events...", 0);
                
                // Initialize parsing state
                const individuals = [];
                const families = [];
                const places = new Set();
                let currentIndividual = null;
                let currentFamily = null;
                let currentEvent = null;
                
                // Process in chunks with UI yielding
                let chunkStart = 0;
                let errorCount = 0;
                while (chunkStart < lines.length && !isProcessingCancelled) {
                    const chunkEnd = Math.min(chunkStart + CHUNK_SIZE_LINES, lines.length);
                    const chunk = lines.slice(chunkStart, chunkEnd);
                    
                    try {
                        // Process this chunk
                        const result = processGedcomChunk(chunk, {
                            individuals,
                            families,
                            places,
                            currentIndividual,
                            currentFamily,
                            currentEvent,
                            lineOffset: chunkStart
                        });
                        
                        // Update state with chunk results
                        currentIndividual = result.currentIndividual;
                        currentFamily = result.currentFamily;
                        currentEvent = result.currentEvent;
                        
                    } catch (error) {
                        // Handle chunk processing errors gracefully
                        errorCount++;
                        const result = handleChunkProcessingError(chunk, error, Math.floor(chunkStart / CHUNK_SIZE_LINES));
                        currentIndividual = result.currentIndividual;
                        currentEvent = result.currentEvent;
                        
                        // If too many errors, consider fallback
                        if (errorCount > 10) {
                            console.warn('Too many chunk errors, attempting fallback processing');
                            hideProcessingIndicator();
                            const fallbackSuccess = await fallbackToOriginalProcessing(file);
                            if (!fallbackSuccess) {
                                throw new Error('Both chunked and fallback processing failed');
                            }
                            return;
                        }
                    }
                    
                    // Update progress
                    processedLines = chunkEnd;
                    const percentage = Math.round((processedLines / totalLines) * 100);
                    updateProcessingStatus("Processing individuals and events...", percentage);
                    updateEstimatedTime();
                    
                    // Yield to UI thread to prevent blocking
                    await new Promise(resolve => setTimeout(resolve, 10));
                    
                    // Trigger garbage collection hint for very large files
                    if (chunkStart % (CHUNK_SIZE_LINES * 50) === 0) {
                        triggerGarbageCollection();
                    }
                    
                    chunkStart = chunkEnd;
                }
                
                if (isProcessingCancelled) {
                    updateProcessingStatus("Processing cancelled", 0);
                    await new Promise(resolve => setTimeout(resolve, 1000));
                    hideProcessingIndicator();
                    return;
                }
                
                // Update global state with processed data
                gedcomIndividuals = individuals;
                gedcomFamilies = families;
                gedcomPlaces = Array.from(places);
                
                // Build relationship intelligence
                buildRelationshipMap(individuals, families);
                calculateFamilyTreeStats(individuals);
                
                updateProcessingStatus("Processing complete!", 100);
                await new Promise(resolve => setTimeout(resolve, 500));
                
                // Hide processing indicator and show completion
                hideProcessingIndicator();
                showFileLoadedIndicator(file.name);
                
            } catch (error) {
                console.error("Error in chunked processing:", error);
                hideProcessingIndicator();
                throw error;
            }
        }
        
        // Process a single chunk of GEDCOM lines
        function processGedcomChunk(lines, state) {
            const { individuals, families, places, lineOffset } = state;
            let { currentIndividual, currentFamily, currentEvent } = state;
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                if (!line) continue;
                
                const match = line.match(/^(\d+)\s+(@\w+@\s+)?(\w+)(\s+(.*))?$/);
                if (!match) continue;
                
                const level = parseInt(match[1]);
                const tag = match[3];
                const value = match[5] || '';
                const id = match[2] ? match[2].trim() : '';
                
                if (level === 0 && tag === 'INDI') {
                    currentIndividual = { id: id, name: {}, events: [], families: [] };
                    individuals.push(currentIndividual);
                }
                else if (level === 0 && tag === 'FAM') {
                    currentFamily = { id: id, husband: '', wife: '', children: [] };
                    families.push(currentFamily);
                } 
                else if (level === 1 && tag === 'NAME' && currentIndividual) {
                    // Parse name: GivenNames /SURNAME/ Suffix
                    const nameParts = value.split('/');
                    if (nameParts.length >= 2) {
                        const givenPart = nameParts[0].trim();
                        const surname = nameParts[1].trim();
                        const suffixPart = nameParts.length > 2 ? nameParts[2].trim() : '';
                        
                        // Split given names into first and middle
                        const givenNames = givenPart.split(/\s+/).filter(n => n.length > 0);
                        const given = givenNames.length > 0 ? givenNames[0] : '';
                        const middle = givenNames.length > 1 ? givenNames.slice(1).join(' ') : '';
                        
                        currentIndividual.name = {
                            given: given,
                            surname: surname,
                            middle: middle,
                            suffix: suffixPart
                        };
                    } else {
                        currentIndividual.name = { full: value };
                    }
                }
                // Process events
                else if (level === 1 && ['BIRT', 'DEAT', 'MARR', 'BURI', 'CENS'].includes(tag) && currentIndividual) {
                    const eventType = 
                        tag === 'BIRT' ? 'Birth' : 
                        tag === 'DEAT' ? 'Death' : 
                        tag === 'MARR' ? 'Marriage' :
                        tag === 'BURI' ? 'Burial' :
                        tag === 'CENS' ? 'Census' : tag;
                    
                    currentEvent = { type: eventType, date: '', place: '' };
                    currentIndividual.events.push(currentEvent);
                }
                else if (level === 2 && tag === 'DATE' && currentEvent) {
                    currentEvent.date = value;
                }
                else if (level === 2 && tag === 'PLAC' && currentEvent) {
                    currentEvent.place = value;
                    if (value) places.add(value);
                }
                // Process family relationships
                else if (level === 1 && tag === 'HUSB' && currentFamily) {
                    currentFamily.husband = value;
                }
                else if (level === 1 && tag === 'WIFE' && currentFamily) {
                    currentFamily.wife = value;
                }
                else if (level === 1 && tag === 'CHIL' && currentFamily) {
                    currentFamily.children.push(value);
                }
                else if (level === 1 && tag === 'FAMS' && currentIndividual) {
                    currentIndividual.families.push({ role: 'spouse', familyId: value });
                }
                else if (level === 1 && tag === 'FAMC' && currentIndividual) {
                    currentIndividual.families.push({ role: 'child', familyId: value });
                }
                // Skip other GEDCOM tags for performance
            }
            
            return { currentIndividual, currentFamily, currentEvent };
        }
        
        // ============================================================================
        // GEDCOM RELATIONSHIP INTELLIGENCE SECTION
        // ============================================================================
        
        // Build relationship map from parsed GEDCOM data
        function buildRelationshipMap(individuals, families) {
            try {
                relationshipMap.clear();
                
                // Create individual lookup for faster access
                const individualLookup = new Map();
                individuals.forEach(individual => {
                    if (individual && individual.id) {
                        individualLookup.set(individual.id, individual);
                    }
                });
            
            // Process each family to build relationships
            families.forEach(family => {
                const husband = family.husband ? individualLookup.get(family.husband) : null;
                const wife = family.wife ? individualLookup.get(family.wife) : null;
                const children = family.children.map(childId => individualLookup.get(childId)).filter(Boolean);
                
                // Build spouse relationships
                if (husband && wife) {
                    addRelationship(husband.id, wife.id, 'spouse', 1.0);
                    addRelationship(wife.id, husband.id, 'spouse', 1.0);
                }
                
                // Build parent-child relationships
                if (husband) {
                    children.forEach(child => {
                        addRelationship(husband.id, child.id, 'child', 0.9);
                        addRelationship(child.id, husband.id, 'parent', 0.9);
                    });
                }
                
                if (wife) {
                    children.forEach(child => {
                        addRelationship(wife.id, child.id, 'child', 0.9);
                        addRelationship(child.id, wife.id, 'parent', 0.9);
                    });
                }
                
                // Build sibling relationships
                for (let i = 0; i < children.length; i++) {
                    for (let j = i + 1; j < children.length; j++) {
                        addRelationship(children[i].id, children[j].id, 'sibling', 0.8);
                        addRelationship(children[j].id, children[i].id, 'sibling', 0.8);
                    }
                }
            });
            } catch (error) {
                console.warn('Error building relationship map:', error);
                relationshipMap.clear();
            }
        }
        
        // Add a relationship to the map with confidence scoring
        function addRelationship(fromId, toId, type, confidence) {
            if (!relationshipMap.has(fromId)) {
                relationshipMap.set(fromId, []);
            }
            
            const relationships = relationshipMap.get(fromId);
            relationships.push({
                relatedPersonId: toId,
                relationshipType: type,
                confidence: confidence
            });
        }
        
        // Get relationships for a specific person with confidence threshold
        function getRelationships(personId, minConfidence = 0.7) {
            const relationships = relationshipMap.get(personId) || [];
            return relationships.filter(rel => rel.confidence >= minConfidence);
        }
        
        // Find person by name with fuzzy matching
        function findPersonByName(surname, givenName, middleName = '') {
            const matches = [];
            
            gedcomIndividuals.forEach(individual => {
                if (!individual.name) return;
                
                const score = calculateNameMatchScore(individual.name, surname, givenName, middleName);
                if (score > 0.6) {
                    matches.push({
                        individual,
                        score,
                        confidence: score
                    });
                }
            });
            
            // Sort by confidence score, highest first
            return matches.sort((a, b) => b.confidence - a.confidence);
        }
        
        // Calculate name matching confidence score
        function calculateNameMatchScore(gedcomName, surname, givenName, middleName) {
            let score = 0;
            let maxScore = 0;
            
            // Surname matching (most important)
            if (gedcomName.surname && surname) {
                maxScore += 3;
                const surnameMatch = fuzzyStringMatch(gedcomName.surname.toLowerCase(), surname.toLowerCase());
                score += surnameMatch * 3;
            }
            
            // Given name matching
            if (gedcomName.given && givenName) {
                maxScore += 2;
                const givenMatch = fuzzyStringMatch(gedcomName.given.toLowerCase(), givenName.toLowerCase());
                score += givenMatch * 2;
            }
            
            // Middle name matching (optional)
            if (gedcomName.middle && middleName) {
                maxScore += 1;
                const middleMatch = fuzzyStringMatch(gedcomName.middle.toLowerCase(), middleName.toLowerCase());
                score += middleMatch * 1;
            }
            
            return maxScore > 0 ? score / maxScore : 0;
        }
        
        // Fuzzy string matching for genealogical name variations
        function fuzzyStringMatch(str1, str2) {
            if (str1 === str2) return 1.0;
            
            // Handle common abbreviations and nicknames
            const nicknames = {
                'william': ['bill', 'will', 'billy'],
                'robert': ['bob', 'rob', 'bobby'],
                'richard': ['rick', 'dick', 'rich'],
                'james': ['jim', 'jimmy'],
                'john': ['jack', 'johnny'],
                'elizabeth': ['liz', 'beth', 'betty', 'eliza'],
                'margaret': ['maggie', 'meg', 'peggy']
            };
            
            // Check nickname matches
            for (const [full, nicks] of Object.entries(nicknames)) {
                if ((str1 === full && nicks.includes(str2)) || 
                    (str2 === full && nicks.includes(str1)) ||
                    (nicks.includes(str1) && nicks.includes(str2))) {
                    return 0.9;
                }
            }
            
            // Levenshtein distance based matching
            const distance = levenshteinDistance(str1, str2);
            const maxLength = Math.max(str1.length, str2.length);
            
            if (maxLength === 0) return 1.0;
            return Math.max(0, 1 - (distance / maxLength));
        }
        
        // Levenshtein distance calculation
        function levenshteinDistance(str1, str2) {
            const matrix = Array(str2.length + 1).fill(null).map(() => Array(str1.length + 1).fill(null));
            
            for (let i = 0; i <= str1.length; i++) matrix[0][i] = i;
            for (let j = 0; j <= str2.length; j++) matrix[j][0] = j;
            
            for (let j = 1; j <= str2.length; j++) {
                for (let i = 1; i <= str1.length; i++) {
                    const substitutionCost = str1[i - 1] === str2[j - 1] ? 0 : 1;
                    matrix[j][i] = Math.min(
                        matrix[j][i - 1] + 1,
                        matrix[j - 1][i] + 1,
                        matrix[j - 1][i - 1] + substitutionCost
                    );
                }
            }
            
            return matrix[str2.length][str1.length];
        }
        
        // Calculate family tree statistics and insights
        function calculateFamilyTreeStats(individuals) {
            try {
                familyTreeStats = {
                    totalIndividuals: individuals.length,
                    individualsWithNames: 0,
                    individualsWithDates: 0,
                    dateRange: { earliest: null, latest: null },
                    commonSurnames: new Map(),
                    relationshipCoverage: 0
                };
            
            let datesFound = [];
            
            individuals.forEach(individual => {
                // Count named individuals
                if (individual.name && (individual.name.surname || individual.name.given || individual.name.full)) {
                    familyTreeStats.individualsWithNames++;
                    
                    // Count surnames
                    if (individual.name.surname) {
                        const surname = individual.name.surname.toUpperCase();
                        familyTreeStats.commonSurnames.set(surname, 
                            (familyTreeStats.commonSurnames.get(surname) || 0) + 1);
                    }
                }
                
                // Process dates from events
                if (individual.events) {
                    individual.events.forEach(event => {
                        if (event.date) {
                            familyTreeStats.individualsWithDates++;
                            const parsedDate = parseGenealogyDate(event.date);
                            if (parsedDate.year) {
                                datesFound.push(parsedDate.year);
                            }
                        }
                    });
                }
            });
            
            // Calculate date range
            if (datesFound.length > 0) {
                familyTreeStats.dateRange.earliest = Math.min(...datesFound);
                familyTreeStats.dateRange.latest = Math.max(...datesFound);
            }
            
            // Calculate relationship coverage
            const peopleWithRelationships = Array.from(relationshipMap.keys()).length;
            familyTreeStats.relationshipCoverage = individuals.length > 0 ? 
                peopleWithRelationships / individuals.length : 0;
            
            // Sort common surnames by frequency
            familyTreeStats.topSurnames = Array.from(familyTreeStats.commonSurnames.entries())
                .sort((a, b) => b[1] - a[1])
                .slice(0, 10);
            } catch (error) {
                console.warn('Error calculating family tree stats:', error);
                familyTreeStats = {
                    totalIndividuals: 0,
                    individualsWithNames: 0,
                    individualsWithDates: 0,
                    dateRange: { earliest: null, latest: null },
                    commonSurnames: new Map(),
                    relationshipCoverage: 0,
                    topSurnames: []
                };
            }
        }
        
        // Parse genealogical dates to extract years for analysis
        function parseGenealogyDate(dateStr) {
            if (!dateStr) return { year: null, uncertain: false };
            
            // Handle genealogical prefixes
            const prefixPattern = /^(Abt|Bfr|Aft|Bet|Est|Cal|Int)\s+(.+)$/i;
            const match = dateStr.match(prefixPattern);
            const cleanDate = match ? match[2] : dateStr;
            const uncertain = !!match;
            
            // Extract year from various formats
            const yearMatch = cleanDate.match(/(\d{4})/);
            return {
                year: yearMatch ? parseInt(yearMatch[1]) : null,
                uncertain
            };
        }
        
        // ============================================================================
        // CONTEXTUAL SUGGESTION SYSTEM
        // ============================================================================
        
        // Analyze document context and generate relevant relationship suggestions
        function analyzeDocumentContext(eventType, primaryPersonData) {
            if (!eventType || !primaryPersonData || gedcomIndividuals.length === 0) {
                return { suggestions: [], context: 'insufficient-data' };
            }
            
            // Find primary person in GEDCOM data
            const primaryMatches = findPersonByName(
                primaryPersonData.surname || '',
                primaryPersonData.givenName || '',
                primaryPersonData.middleName || ''
            );
            
            if (primaryMatches.length === 0) {
                return { suggestions: [], context: 'person-not-found' };
            }
            
            const primaryPerson = primaryMatches[0].individual;
            const relationships = getRelationships(primaryPerson.id);
            
            // Generate context-specific suggestions based on document type
            const suggestions = generateContextualSuggestions(eventType, primaryPerson, relationships);
            
            return {
                suggestions,
                context: 'suggestions-available',
                primaryPersonMatch: primaryMatches[0]
            };
        }
        
        // Generate relationship suggestions based on document type
        function generateContextualSuggestions(eventType, primaryPerson, relationships) {
            const suggestions = [];
            const eventLower = eventType.toLowerCase();
            
            // Marriage documents - suggest spouses
            if (eventLower.includes('marriage') || eventLower.includes('wedding')) {
                const spouses = relationships.filter(rel => rel.relationshipType === 'spouse');
                spouses.forEach(spouse => {
                    const spousePerson = gedcomIndividuals.find(p => p.id === spouse.relatedPersonId);
                    if (spousePerson && spousePerson.name) {
                        suggestions.push({
                            person: spousePerson,
                            relationship: 'spouse',
                            confidence: spouse.confidence,
                            reason: 'Marriage documents typically include both spouses'
                        });
                    }
                });
            }
            
            // Birth/Baptism documents - suggest parents
            else if (eventLower.includes('birth') || eventLower.includes('baptism') || eventLower.includes('christening')) {
                const parents = relationships.filter(rel => rel.relationshipType === 'parent');
                parents.forEach(parent => {
                    const parentPerson = gedcomIndividuals.find(p => p.id === parent.relatedPersonId);
                    if (parentPerson && parentPerson.name) {
                        suggestions.push({
                            person: parentPerson,
                            relationship: 'parent',
                            confidence: parent.confidence,
                            reason: 'Birth records often include parent information'
                        });
                    }
                });
            }
            
            // Death documents - suggest spouse and adult children
            else if (eventLower.includes('death') || eventLower.includes('obituary') || eventLower.includes('burial')) {
                // Suggest spouse
                const spouses = relationships.filter(rel => rel.relationshipType === 'spouse');
                spouses.forEach(spouse => {
                    const spousePerson = gedcomIndividuals.find(p => p.id === spouse.relatedPersonId);
                    if (spousePerson && spousePerson.name) {
                        suggestions.push({
                            person: spousePerson,
                            relationship: 'spouse',
                            confidence: spouse.confidence * 0.9, // Slightly lower confidence as spouse might be deceased
                            reason: 'Death records often mention surviving spouse'
                        });
                    }
                });
                
                // Suggest adult children
                const children = relationships.filter(rel => rel.relationshipType === 'child');
                children.forEach(child => {
                    const childPerson = gedcomIndividuals.find(p => p.id === child.relatedPersonId);
                    if (childPerson && childPerson.name) {
                        suggestions.push({
                            person: childPerson,
                            relationship: 'child',
                            confidence: child.confidence * 0.8,
                            reason: 'Death records often list surviving children'
                        });
                    }
                });
            }
            
            // Census documents - suggest household members (family)
            else if (eventLower.includes('census')) {
                // Add all immediate family members for census
                ['spouse', 'child', 'parent'].forEach(relType => {
                    const relatedPeople = relationships.filter(rel => rel.relationshipType === relType);
                    relatedPeople.forEach(related => {
                        const relatedPerson = gedcomIndividuals.find(p => p.id === related.relatedPersonId);
                        if (relatedPerson && relatedPerson.name) {
                            suggestions.push({
                                person: relatedPerson,
                                relationship: relType,
                                confidence: related.confidence * 0.8, // Census may not include all family
                                reason: 'Census records typically include household members'
                            });
                        }
                    });
                });
            }
            
            // Divorce documents - suggest spouse
            else if (eventLower.includes('divorce')) {
                const spouses = relationships.filter(rel => rel.relationshipType === 'spouse');
                spouses.forEach(spouse => {
                    const spousePerson = gedcomIndividuals.find(p => p.id === spouse.relatedPersonId);
                    if (spousePerson && spousePerson.name) {
                        suggestions.push({
                            person: spousePerson,
                            relationship: 'spouse',
                            confidence: spouse.confidence,
                            reason: 'Divorce documents involve both spouses'
                        });
                    }
                });
            }
            
            // Default - suggest most confident relationships
            else {
                // For unknown document types, suggest highest confidence relationships
                const topRelationships = relationships
                    .sort((a, b) => b.confidence - a.confidence)
                    .slice(0, 3); // Top 3 most confident
                    
                topRelationships.forEach(rel => {
                    const relatedPerson = gedcomIndividuals.find(p => p.id === rel.relatedPersonId);
                    if (relatedPerson && relatedPerson.name) {
                        suggestions.push({
                            person: relatedPerson,
                            relationship: rel.relationshipType,
                            confidence: rel.confidence * 0.7, // Lower confidence for generic suggestions
                            reason: 'Related family member from genealogy data'
                        });
                    }
                });
            }
            
            // Sort suggestions by confidence and limit to top 5
            return suggestions
                .sort((a, b) => b.confidence - a.confidence)
                .slice(0, 5)
                .filter(s => s.confidence >= 0.6); // Only show high-confidence suggestions
        }
        
        // Validate chronological appropriateness of suggestions
        function validateChronologicalAppropiateness(suggestions, documentDate) {
            if (!documentDate) return suggestions; // No date validation possible
            
            const docYear = parseGenealogyDate(documentDate).year;
            if (!docYear) return suggestions;
            
            return suggestions.filter(suggestion => {
                const person = suggestion.person;
                if (!person.events) return true; // No date info available, include suggestion
                
                // Check birth and death dates
                const birthEvent = person.events.find(e => e.type === 'Birth');
                const deathEvent = person.events.find(e => e.type === 'Death');
                
                if (birthEvent && birthEvent.date) {
                    const birthYear = parseGenealogyDate(birthEvent.date).year;
                    if (birthYear && docYear < birthYear) {
                        return false; // Person not yet born
                    }
                }
                
                if (deathEvent && deathEvent.date) {
                    const deathYear = parseGenealogyDate(deathEvent.date).year;
                    if (deathYear && docYear > deathYear + 5) {
                        return false; // Person died too long before document
                    }
                }
                
                return true;
            });
        }
        
        // Get family tree insights for display
        function getFamilyTreeInsights() {
            if (!familyTreeStats || familyTreeStats.totalIndividuals < 50) {
                return null; // Don't show insights for small trees
            }
            
            return {
                totalIndividuals: familyTreeStats.totalIndividuals,
                namedIndividuals: familyTreeStats.individualsWithNames,
                dateRange: familyTreeStats.dateRange,
                topSurnames: familyTreeStats.topSurnames.slice(0, 5),
                relationshipCoverage: Math.round(familyTreeStats.relationshipCoverage * 100),
                dataQuality: calculateDataQuality()
            };
        }
        
        // Calculate overall data quality score
        function calculateDataQuality() {
            if (!familyTreeStats) return 0;
            
            const nameCompleteness = familyTreeStats.individualsWithNames / familyTreeStats.totalIndividuals;
            const dateCompleteness = familyTreeStats.individualsWithDates / familyTreeStats.totalIndividuals;
            const relationshipCompleteness = familyTreeStats.relationshipCoverage;
            
            const qualityScore = (nameCompleteness * 0.4 + dateCompleteness * 0.3 + relationshipCompleteness * 0.3) * 100;
            
            return {
                score: Math.round(qualityScore),
                nameCompleteness: Math.round(nameCompleteness * 100),
                dateCompleteness: Math.round(dateCompleteness * 100),
                relationshipCompleteness: Math.round(relationshipCompleteness * 100)
            };
        }
        
        // Progress indicator management functions
        function showProcessingIndicator() {
            elements.uploadZone.classList.add('hidden');
            elements.fileLoadedIndicator.classList.add('hidden');
            elements.gedcomProcessingProgress.classList.remove('hidden');
        }
        
        function hideProcessingIndicator() {
            elements.gedcomProcessingProgress.classList.add('hidden');
            elements.uploadZone.classList.remove('hidden');
        }
        
        function updateProcessingStatus(statusText, percentage) {
            elements.processingStatusText.textContent = statusText;
            elements.processingPercentage.textContent = `${percentage}%`;
            elements.processingProgressBar.style.width = `${percentage}%`;
        }
        
        function updateFileInfo(file) {
            const fileSize = (file.size / (1024 * 1024)).toFixed(1);
            elements.processingFileInfo.textContent = `File: ${file.name} (${fileSize} MB)`;
        }
        
        function updateEstimatedTime() {
            if (!processingStartTime || processedLines === 0) return;
            
            const elapsed = (Date.now() - processingStartTime) / 1000;
            const rate = processedLines / elapsed;
            const remaining = (totalLines - processedLines) / rate;
            
            if (remaining > 0 && remaining < 300) { // Only show if less than 5 minutes
                const minutes = Math.floor(remaining / 60);
                const seconds = Math.round(remaining % 60);
                elements.processingEta.textContent = minutes > 0 
                    ? `ETA: ${minutes}m ${seconds}s` 
                    : `ETA: ${seconds}s`;
            } else {
                elements.processingEta.textContent = '';
            }
        }
        
        function showFileLoadedIndicator(filename) {
            elements.fileLoadedIndicator.classList.remove('hidden');
            elements.loadedFilename.textContent = filename;
        }
        
        // Cancel processing function
        function cancelProcessing() {
            isProcessingCancelled = true;
            currentProcessingFile = null;
            
            // Clean up processing state
            processingStartTime = null;
            totalLines = 0;
            processedLines = 0;
        }
        
        // Enhanced error handling for chunk processing
        function handleChunkProcessingError(chunk, error, chunkIndex) {
            console.warn(`Error processing chunk ${chunkIndex}:`, error);
            
            // Continue processing with next chunk for graceful degradation
            // This allows partial processing even if some chunks fail
            return {
                currentIndividual: null,
                currentEvent: null,
                hasError: true,
                errorMessage: error.message
            };
        }
        
        // Fallback to original processing for compatibility
        async function fallbackToOriginalProcessing(file) {
            try {
                console.log('Falling back to original GEDCOM processing');
                const text = await file.text();
                parseGedcom(text);
                showFileLoadedIndicator(file.name);
                return true;
            } catch (error) {
                console.error('Fallback processing also failed:', error);
                return false;
            }
        }
        
        // Memory management helper
        function triggerGarbageCollection() {
            // Hint for garbage collection between large chunks
            if (window.gc) {
                window.gc();
            }
        }
        
        // Country abbreviation mapping
        const countryAbbreviations = {
            'united states': 'USA',
            'united states of america': 'USA',
            'usa': 'USA',
            'us': 'USA',
            'america': 'USA',
            'canada': 'CAN',
            'england': 'ENG',
            'ireland': 'IRE',
            'scotland': 'SCO',
            'wales': 'WAL',
            'germany': 'GER',
            'deutschland': 'GER',
            'australia': 'AUS',
            'united kingdom': 'UK',
            'great britain': 'UK',
            'britain': 'UK'
        };

        // Place format configurations
        const placeFormats = {
            usa: {
                name: 'USA',
                pattern: 'City, County, State, Country',
                example: 'Wadsworth, Medina County, Ohio, USA',
                placeholder: 'Wadsworth, Medina County, Ohio, USA',
                fields: ['City', 'County', 'State', 'Country']
            },
            canada: {
                name: 'Canada',
                pattern: 'City, Region, Province, Country',
                example: 'Toronto, York Region, Ontario, Canada',
                placeholder: 'Toronto, York Region, Ontario, Canada',
                fields: ['City', 'Region', 'Province', 'Country']
            },
            uk: {
                name: 'UK',
                pattern: 'Town, District, County, Country',
                example: 'Morley, Leeds, Yorkshire, England',
                placeholder: 'Morley, Leeds, Yorkshire, England',
                fields: ['Town', 'District', 'County', 'Country']
            },
            germany: {
                name: 'Germany',
                pattern: 'Stadt, Kreis, State, Country',
                example: 'München, München, Bayern, Germany',
                placeholder: 'München, München, Bayern, Germany',
                fields: ['Stadt', 'Kreis', 'State', 'Country']
            },
            australia: {
                name: 'Australia',
                pattern: 'Town, Shire, State, Country',
                example: 'Blacktown, Blacktown, NSW, Australia',
                placeholder: 'Blacktown, Blacktown, NSW, Australia',
                fields: ['Town', 'Shire', 'State', 'Country']
            },
            generic: {
                name: 'Generic',
                pattern: 'City, Region2, Region1, Country',
                example: 'City, Region2, Region1, Country',
                placeholder: 'City, Region2, Region1, Country',
                fields: ['City', 'Region2', 'Region1', 'Country']
            }
        };

        function getCountryAbbreviation(countryName) {
            const normalized = countryName.toLowerCase().trim();
            return countryAbbreviations[normalized] || countryName;
        }

        // Replace spaces with hyphens for filename formatting
        function formatForFilename(text) {
            return text.replace(/\s+/g, '-');
        }

        // Helper function: Extract and format place for filename
        function getFormattedPlace() {
            let formattedPlace = '';
            if (elements.place.value) {
                // Story 1.4: Use PLACE sub-template for formatting if available
                const placeTemplate = userSettings.placeSubtemplate || '{COUNTRY}.{STATE}.{COUNTY}.{CITY}';
                formattedPlace = processPlaceSubtemplate(elements.place.value, placeTemplate);

                // Format the result for filename (spaces to hyphens)
                formattedPlace = formatForFilename(formattedPlace);
            } else {
                formattedPlace = 'x';
            }
            return formattedPlace;
        }

        // Helper function: Extract and format date for filename
        function getFormattedDate() {
            // Get date from either genealogy input or precise date input
            const currentDateValue = getCurrentDateValue();
            let formattedDate;

            if (currentDateValue) {
                // Story 1.3: Use DATE sub-template for formatting if available
                const dateTemplate = userSettings.dateSubtemplate || '{YYYY}.{MM}.{DD}';
                formattedDate = processDateSubtemplate(currentDateValue, dateTemplate);
            } else {
                formattedDate = 'x';
            }
            return formattedDate;
        }

        // Helper function: Extract and format primary person name for filename
        function getFormattedName() {
            // Construct full name string from form fields
            const surname = elements.surname.value || '';
            const given = elements.givenName.value || '';
            const middle = elements.middleName.value || '';

            // Build full name string: "Given Middle Surname"
            let fullName = '';
            if (given) fullName += given;
            if (middle) fullName += (fullName ? ' ' : '') + middle;
            if (surname) fullName += (fullName ? ' ' : '') + surname;

            if (!fullName) {
                return 'x';
            }

            // Story 1.5: Use NAME sub-template for formatting if available
            const nameTemplate = userSettings.nameSubtemplate || '{SURNAME:upper}.{GIVEN}';
            let formattedName = processNameSubtemplate(fullName, nameTemplate);

            // Format the result for filename (spaces to hyphens)
            formattedName = formatForFilename(formattedName);

            return formattedName;
        }

        // ============================================================================
        // SUB-TEMPLATE PROCESSOR - CORE ENGINE (Story 1.1) + ENHANCEMENTS (Story 1.2)
        // ============================================================================
        // Processes template strings with placeholders and returns formatted output.
        // Supports:
        // - Placeholder replacement: {YYYY}, {MM}, {GIVEN}, etc.
        // - Format modifiers: {PLACEHOLDER:modifier} where modifier is :upper, :lower, :title, :abbrev
        // - Multiple modifiers (AC #8): {PLACEHOLDER:mod1:mod2:mod3} applies only LAST modifier
        // - Case-insensitive modifiers (AC #6): :UPPER, :upper, :Upper all work the same
        // - Invalid modifier handling (AC #7): Logs warning, returns original value

        function processSubTemplate(template, data, options = {}) {
            // Default options
            const { missingValueHandler = 'x', caseSensitive = false } = options;

            if (!template || typeof template !== 'string') return '';

            let result = template;

            // Regex pattern for matching placeholders: {PLACEHOLDER} or {PLACEHOLDER:modifier} or {PLACEHOLDER:mod1:mod2:...}
            // Captures: [1] = placeholder name, [2] = optional modifier chain (without leading colon)
            // Note: Modifiers are case-insensitive, so we accept [a-zA-Z]+ and convert to lowercase
            const placeholderRegex = /\{([A-Z]+)(?::([a-zA-Z:]+))?\}/g;

            // Replace all placeholders in the template
            result = result.replace(placeholderRegex, (match, placeholder, modifier) => {
                // Map placeholder names to data keys (YYYY → year, MM → month, etc.)
                const keyMap = {
                    // Date placeholders
                    'YYYY': 'year',
                    'YY': 'year',
                    'MM': 'month',
                    'M': 'month',
                    'DD': 'day',
                    'D': 'day',
                    // Place placeholders
                    'COUNTRY': 'country',
                    'C': 'country',
                    'STATE': 'state',
                    'S': 'state',
                    'COUNTY': 'county',
                    'CO': 'county',
                    'CITY': 'city',
                    'CI': 'city',
                    // Name placeholders
                    'SURNAME': 'surname',
                    'GIVEN': 'given',
                    'MIDDLE': 'middle'
                };

                const dataKey = keyMap[placeholder];

                // If placeholder not recognized, log warning and preserve
                if (!dataKey) {
                    console.warn(`Unknown placeholder: ${placeholder}`);
                    return match;
                }

                // Get value from data object
                let value = data[dataKey];

                // Handle missing/null/undefined/empty values
                if (value === null || value === undefined || value === '') {
                    return missingValueHandler;
                }

                // Convert to string
                value = String(value);

                // Apply padding rules for date placeholders
                if ((placeholder === 'MM' || placeholder === 'DD') && !isNaN(value)) {
                    value = String(value).padStart(2, '0');
                } else if ((placeholder === 'YY') && !isNaN(value)) {
                    // Extract last 2 digits of year
                    const yearNum = parseInt(value);
                    value = String(yearNum % 100).padStart(2, '0');
                }

                // Apply format modifiers if present
                if (modifier) {
                    // Handle multiple modifiers separated by colons (e.g., "upper:lower:title")
                    // AC #8: Apply only the LAST modifier in the chain
                    const modifiers = modifier.split(':');
                    const lastModifier = modifiers[modifiers.length - 1];
                    value = applyModifier(value, lastModifier);
                }

                return value;
            });

            return result;
        }

        // Helper function to apply format modifiers (Story 1.2)
        // Applies text transformation modifiers to placeholder values
        // Supports: :upper, :lower, :title, :abbrev
        // AC #6: Case-insensitive modifier matching (all case variants work the same)
        // AC #7: Invalid modifiers logged with console.warn(), original value returned unchanged
        function applyModifier(value, modifier) {
            if (!modifier || !value) return value;

            // AC #6: Convert modifier to lowercase for case-insensitive matching
            const mod = modifier.toLowerCase();

            switch (mod) {
                case 'upper':
                    // AC #2: Convert text to uppercase
                    return value.toUpperCase();
                case 'lower':
                    // AC #3: Convert text to lowercase
                    return value.toLowerCase();
                case 'title':
                    // AC #4: Convert text to title case (capitalize first letter of each word)
                    return toTitleCase(value);
                case 'abbrev':
                    // AC #5: Take first letter only and uppercase it
                    return value.charAt(0).toUpperCase();
                default:
                    // AC #7: Invalid modifiers logged but don't crash, return original value
                    console.warn(`Unknown modifier: ${modifier}`);
                    return value;
            }
        }

        // Helper function for title case conversion (Story 1.2 - AC #4)
        // Converts a string to title case by capitalizing first letter of each word
        // Example: "john william" → "John William"
        function toTitleCase(str) {
            return str.replace(/\w\S*/g, (txt) =>
                txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase()
            );
        }

        // Helper function: Format additional people using nameFormat template
        function formatAdditionalPeople(additionalPeople, nameFormat = '{GIVEN}.{SURNAME}|+') {
            // Return empty string if no additional people exist
            if (!additionalPeople || !Array.isArray(additionalPeople) || additionalPeople.length === 0) {
                return '';
            }

            // Parse nameFormat: split on pipe character (|)
            // Format: {GIVEN}.{SURNAME}|+  where left side is template, right side is delimiter
            let formatTemplate = nameFormat;
            let delimiter = '';

            const pipeIndex = nameFormat.lastIndexOf('|');
            if (pipeIndex !== -1) {
                formatTemplate = nameFormat.substring(0, pipeIndex);
                delimiter = nameFormat.substring(pipeIndex + 1);
            }

            // Format each person using processNameSubtemplate() for consistency
            // This ensures format modifiers (:upper, :lower, :title, :abbrev) work correctly
            const formattedPeople = additionalPeople.map(person => {
                // Construct full name string from person object
                const nameParts = [
                    person.givenName || '',
                    person.middleName || '',
                    person.surname || ''
                ].filter(part => part.trim() !== '');

                const fullName = nameParts.join(' ') || '';

                // Use processNameSubtemplate() to apply template with modifier support
                // This function already handles format modifiers and missing components
                const formatted = processNameSubtemplate(fullName, formatTemplate);

                // Format for filename (replace spaces with hyphens, etc.)
                return formatForFilename(formatted);
            });

            // Join all formatted people with the delimiter
            return formattedPeople.join(delimiter);
        }

        // Parse filename template and replace all placeholders
        function parseFilenameTemplate(template) {
            // Get all formatted values using helper functions
            const formattedPlace = getFormattedPlace();
            const formattedDate = getFormattedDate();
            const formattedName = getFormattedName();  // Story 1.5: NAME sub-template support

            // Get individual field values
            const formattedType = formatForFilename(elements.eventType.value || 'x');
            const formattedSurname = (elements.surname.value || 'x').toUpperCase();
            const formattedGiven = formatForFilename(elements.givenName.value || '');
            const formattedMiddle = formatForFilename(elements.middleName.value || '');
            const formattedInfo = formatForFilename(elements.fileInfo.value || '');
            const fileExtension = elements.fileExtension.value || '.jpg';

            // Format additional people using nameFormat from settings
            const nameFormat = userSettings.nameFormat || '{GIVEN}.{SURNAME}|+';
            const additionalPeopleStr = formatAdditionalPeople(additionalPeople, nameFormat);

            // Replace all placeholders using global regex
            let result = template;

            // Create a map of all placeholder values for conditional checking
            const placeholderValues = {
                '{TYPE}': formattedType,
                '{PLACE}': formattedPlace,
                '{DATE}': formattedDate,
                '{NAME}': formattedName,  // Story 1.5: NAME placeholder
                '{SURNAME}': formattedSurname,
                '{GIVEN}': formattedGiven,
                '{MIDDLE}': formattedMiddle,
                '{INFO}': formattedInfo,
                '{EXT}': fileExtension,
                '{AdditionalPeople}': additionalPeopleStr
            };

            // Process conditional blocks {{ ... }} BEFORE replacing placeholders
            // This allows conditional logic to work with any template tag
            // Pattern: {{ then (non-braces OR properly-formed placeholders) then }}
            const conditionalRegex = /\{\{((?:[^{}]|\{[^}]*\})*)\}\}/g;
            result = result.replace(conditionalRegex, (match, content) => {
                // Extract all placeholders from the conditional block
                const placeholderRegex = /\{[^}]+\}/g;
                const placeholdersInBlock = content.match(placeholderRegex) || [];

                // Check if ANY placeholder in this block has non-empty content
                const hasContent = placeholdersInBlock.some(placeholder => {
                    return placeholderValues[placeholder] && placeholderValues[placeholder] !== '';
                });

                // If any placeholder has content, keep the block (will be replaced next)
                // Otherwise, remove the entire {{ }} block
                return hasContent ? content : '';
            });

            // Now replace all placeholders
            result = result.replace(/{TYPE}/g, formattedType);
            result = result.replace(/{PLACE}/g, formattedPlace);
            result = result.replace(/{DATE}/g, formattedDate);
            result = result.replace(/{NAME}/g, formattedName);  // Story 1.5: NAME placeholder
            result = result.replace(/{SURNAME}/g, formattedSurname);
            result = result.replace(/{GIVEN}/g, formattedGiven);
            result = result.replace(/{MIDDLE}/g, formattedMiddle);
            result = result.replace(/{INFO}/g, formattedInfo);
            result = result.replace(/{EXT}/g, fileExtension);
            result = result.replace(/{AdditionalPeople}/g, additionalPeopleStr);

            return result;
        }

        // ============================================================================
        // DATE SUB-TEMPLATE PROCESSOR (Story 1.3)
        // ============================================================================
        // Parses date strings into year, month, day components for template processing

        // Story 1.3: Parse date input and extract components
        function parseDateInput(dateString) {
            if (!dateString || dateString.trim() === '') {
                return { year: 'x', month: 'x', day: 'x' };
            }

            const trimmed = dateString.trim();
            let year = 'x', month = 'x', day = 'x';

            // Handle ISO format: YYYY-MM-DD
            if (trimmed.match(/^\d{4}-\d{2}-\d{2}$/)) {
                const parts = trimmed.split('-');
                year = parts[0];
                month = parts[1];
                day = parts[2];
                return { year, month, day };
            }

            // Handle partial dates: YYYY-MM or YYYY
            if (trimmed.match(/^\d{4}(-\d{2})?$/)) {
                const parts = trimmed.split('-');
                year = parts[0];
                month = (parts[1]) ? parts[1] : 'x';
                day = 'x';
                return { year, month, day };
            }

            // Handle genealogical formats: "Abt 1850", "Bef 1900-06", "Aft 1920"
            const genealogicalMatch = trimmed.match(/(Abt|Bef|Aft)?\s*(\d{4})(?:-(\d{2}))?(?:-(\d{2}))?/);
            if (genealogicalMatch) {
                year = genealogicalMatch[2];
                month = genealogicalMatch[3] || 'x';
                day = genealogicalMatch[4] || 'x';
                return { year, month, day };
            }

            // If we can only extract a year, use it
            const yearMatch = trimmed.match(/\b(\d{4})\b/);
            if (yearMatch) {
                year = yearMatch[1];
                return { year, month: 'x', day: 'x' };
            }

            // Default: return all missing values
            return { year: 'x', month: 'x', day: 'x' };
        }

        // Story 1.3: Process DATE sub-template with custom date formatting
        function processDateSubtemplate(dateString, template) {
            // Use default template if empty
            const dateTemplate = template || '{YYYY}.{MM}.{DD}';

            // Parse date input to extract components
            const dateComponents = parseDateInput(dateString);

            // Create data object for processSubTemplate
            const data = {
                year: dateComponents.year === 'x' ? null : dateComponents.year,
                month: dateComponents.month === 'x' ? null : dateComponents.month,
                day: dateComponents.day === 'x' ? null : dateComponents.day
            };

            // Use Story 1.1 processSubTemplate to apply the template
            const result = processSubTemplate(dateTemplate, data, { missingValueHandler: 'x' });
            return result;
        }

        // Story 1.4: Parse place input and extract components (COUNTRY, STATE, COUNTY, CITY)
        // Handles GEDCOM format: "City, County, State, Country" (comma-separated)
        // Also handles single component places (e.g., just "London" or just "USA")
        function parsePlaceInput(placeString) {
            if (!placeString || placeString.trim() === '') {
                return { country: 'x', state: 'x', county: 'x', city: 'x' };
            }

            const trimmed = placeString.trim();

            // Split by comma to get individual components
            const parts = trimmed.split(',').map(part => part.trim());

            // GEDCOM format: City, County, State, Country (4 components from smallest to largest)
            // We need to fill: { city, county, state, country }

            let city = 'x', county = 'x', state = 'x', country = 'x';

            // Determine how many parts we have and map them accordingly
            if (parts.length === 4) {
                // Full GEDCOM format: City, County, State, Country
                city = parts[0] || 'x';
                county = parts[1] || 'x';
                state = parts[2] || 'x';
                country = parts[3] || 'x';
            } else if (parts.length === 3) {
                // Assume: City, State, Country (skip county)
                city = parts[0] || 'x';
                state = parts[1] || 'x';
                country = parts[2] || 'x';
            } else if (parts.length === 2) {
                // Assume: City, Country OR State, Country
                // Heuristic: if first part is short and uppercase-ish, it's a state code
                // Otherwise, treat first as city
                city = parts[0] || 'x';
                country = parts[1] || 'x';
            } else if (parts.length === 1) {
                // Single component: try to guess what it is
                // Common heuristics:
                // - If it's 2-3 chars and all uppercase: likely a country code
                // - Otherwise: could be city or country
                // For now, treat single component as city if it looks like a place, otherwise country
                const single = parts[0];

                // Common country codes and abbreviations
                const countryCodes = ['USA', 'UK', 'CA', 'AU', 'DE', 'FR', 'ES', 'IT', 'NL', 'BE', 'CH', 'SE', 'NO', 'DK'];
                const isCountryCode = countryCodes.some(code => single.toUpperCase() === code) || single.length <= 3;

                if (isCountryCode || single.toUpperCase() === single) {
                    country = single;
                } else {
                    city = single;
                }
            }

            return { country, state, county, city };
        }

        // Story 1.4: Process PLACE sub-template with custom place formatting
        // Uses parsePlaceInput to extract components, then applies template
        function processPlaceSubtemplate(placeString, template) {
            // Use default template if empty: reverse hierarchy matching v1.0.3
            const placeTemplate = template || '{COUNTRY}.{STATE}.{COUNTY}.{CITY}';

            // Parse place input to extract components
            const placeComponents = parsePlaceInput(placeString);

            // Create data object for processSubTemplate
            // Note: processSubTemplate uses a keyMap that recognizes COUNTRY/C, STATE/S, COUNTY/CO, CITY/CI
            const data = {
                country: placeComponents.country === 'x' ? null : placeComponents.country,
                state: placeComponents.state === 'x' ? null : placeComponents.state,
                county: placeComponents.county === 'x' ? null : placeComponents.county,
                city: placeComponents.city === 'x' ? null : placeComponents.city
            };

            // Use Story 1.1 processSubTemplate to apply the template
            // This will handle placeholder replacement, padding (if applicable), and format modifiers
            const result = processSubTemplate(placeTemplate, data, { missingValueHandler: 'x' });
            return result;
        }

        // Story 1.5: Parse name input and extract components (SURNAME, GIVEN, MIDDLE)
        // Handles full names: "John Robert Smith" → {given: "John", middle: "Robert", surname: "Smith"}
        // Handles two-part names: "John Smith" → {given: "John", surname: "Smith", middle: 'x'}
        // Handles single names: "John" → {given: "John", surname: 'x', middle: 'x'}
        function parseNameInput(nameString) {
            if (!nameString || nameString.trim() === '') {
                return { surname: 'x', given: 'x', middle: 'x' };
            }

            const trimmed = nameString.trim();

            // Split by spaces to get individual name parts
            const parts = trimmed.split(/\s+/).filter(part => part.length > 0);

            let given = 'x', middle = 'x', surname = 'x';

            // Determine how many parts we have and map them accordingly
            if (parts.length === 3) {
                // Full name format: Given Middle Surname
                given = parts[0];
                middle = parts[1];
                surname = parts[2];
            } else if (parts.length === 2) {
                // Two-part name: Given Surname
                given = parts[0];
                surname = parts[1];
            } else if (parts.length === 1) {
                // Single name: treat as given name
                given = parts[0];
            } else if (parts.length > 3) {
                // More than 3 parts: First is given, last is surname, middle parts combined as middle
                given = parts[0];
                middle = parts.slice(1, -1).join(' ');
                surname = parts[parts.length - 1];
            }

            return { surname, given, middle };
        }

        // Story 1.5: Process NAME sub-template with custom name formatting
        // Uses parseNameInput to extract components, then applies template
        function processNameSubtemplate(nameString, template) {
            // Use default template if empty: common genealogy pattern
            const nameTemplate = template || '{SURNAME:upper}.{GIVEN}';

            // Parse name input to extract components
            const nameComponents = parseNameInput(nameString);

            // Create data object for processSubTemplate
            const data = {
                surname: nameComponents.surname === 'x' ? null : nameComponents.surname,
                given: nameComponents.given === 'x' ? null : nameComponents.given,
                middle: nameComponents.middle === 'x' ? null : nameComponents.middle
            };

            // Use Story 1.1 processSubTemplate to apply the template
            // This will handle placeholder replacement and format modifiers
            const result = processSubTemplate(nameTemplate, data, { missingValueHandler: 'x' });
            return result;
        }

        // Generate filename
        function generateFilename() {
            // Check if custom template is enabled
            if (userSettings.useCustomTemplate && userSettings.filenameTemplate) {
                try {
                    const filename = parseFilenameTemplate(userSettings.filenameTemplate);
                    elements.generatedFilename.value = filename;
                    generateExifCommand();
                    return;
                } catch (error) {
                    console.warn('Template parsing failed, falling back to default:', error);
                    // Fall through to default logic
                }
            }

            let formattedPlace = '';
            if (elements.place.value) {
                // Parse place input (smallest to largest: City, County, State, Country)
                const placeParts = elements.place.value.split(',').map(part => part.trim());
                
                // Ensure we have exactly 4 parts, padding with empty strings if needed
                while (placeParts.length < 4) {
                    placeParts.push('');
                }
                
                // For filename: reverse order (largest to smallest) and format
                const reversedParts = [...placeParts].reverse();
                
                // Apply country abbreviation to the first element (country) BEFORE formatting
                if (reversedParts[0]) {
                    reversedParts[0] = getCountryAbbreviation(reversedParts[0]) || reversedParts[0];
                }
                
                // Now format all parts for filename (spaces to hyphens)
                const formattedParts = reversedParts.map(part => part ? formatForFilename(part) : '');
                
                formattedPlace = formattedParts
                    .map(part => part || 'x')  // Replace empty parts with 'x'
                    .join('.');
            }
            
            // Get date from either genealogy input or precise date input
            const currentDateValue = getCurrentDateValue();
            let formattedDate;
            
            if (currentDateValue) {
                // Use genealogical date formatting
                formattedDate = formatGenealogyDateForFilename(currentDateValue);
            } else {
                formattedDate = 'x';
            }
            
            // Generate names based on format and number of people
            let formattedNames = '';
            if (elements.surname.value) {
                // Surname is uppercase, given names keep original case
                formattedNames = formatForFilename(elements.surname.value).toUpperCase();
                if (elements.givenName.value) {
                    formattedNames += '.' + formatForFilename(elements.givenName.value);
                    if (elements.middleName.value) {
                        formattedNames += '.' + formatForFilename(elements.middleName.value);
                    }
                }
            } else {
                formattedNames = 'x';
            }

            // Handle additional people
            if (elements.includeAdditionalPeople.checked && additionalPeople.length > 0) {
                const nameFormat = userSettings.nameFormat || '{GIVEN}.{SURNAME}|+';
                
                // Build names array
                const people = [];
                
                // First person
                if (elements.surname.value) {
                    const person1 = {
                        surname: formatForFilename(elements.surname.value).toUpperCase(),
                        given: formatForFilename(elements.givenName.value || ''),
                        middle: formatForFilename(elements.middleName.value || '')
                    };
                    people.push(person1);
                }
                
                // Additional people from dynamic array
                additionalPeople.forEach(person => {
                    if (person.surname) {
                        const formattedPerson = {
                            surname: formatForFilename(person.surname).toUpperCase(),
                            given: formatForFilename(person.givenName || ''),
                            middle: formatForFilename(person.middleName || '')
                        };
                        people.push(formattedPerson);
                    }
                });
                
                // Format names based on selected format
                switch(nameFormat) {
                    case 'compact':
                        formattedNames = people.map(person => {
                            let name = person.surname;
                            if (person.given) {
                                name += '.' + person.given;
                            }
                            return name;
                        }).join('-');
                        break;
                        
                    case 'and':
                        formattedNames = people.map(person => {
                            let name = person.surname;
                            if (person.given) {
                                name += '.' + person.given;
                                if (person.middle) {
                                    name += '.' + person.middle;
                                }
                            }
                            return name;
                        }).join('-and-');
                        break;
                        
                    case 'underscore':
                        formattedNames = people.map(person => {
                            let name = person.surname;
                            if (person.given) {
                                name += '.' + person.given;
                                if (person.middle) {
                                    name += '.' + person.middle;
                                }
                            }
                            return name;
                        }).join('_');
                        break;
                }
            }
            
            const components = [
                formatForFilename(elements.eventType.value || 'x'),
                formattedPlace || 'x',
                formattedDate,
                formattedNames,
                formatForFilename(elements.fileInfo.value || '')
            ].filter(Boolean);
            
            const filename = components.join('_') + elements.fileExtension.value;
            elements.generatedFilename.value = filename;
            
            generateExifCommand();
        }

        // Command Validation System
        function validateEXIFCommand(command) {
            const errors = [];
            
            // Check for proper quoting
            const unbalancedQuotes = (command.match(/"/g) || []).length % 2 !== 0;
            if (unbalancedQuotes) {
                errors.push("Unbalanced quotes in command");
            }
            
            // Check for proper field formatting
            const fieldPattern = /-[A-Za-z0-9:-]+="[^"]*"/g;
            const invalidFields = command.match(/-[A-Za-z0-9:-]+=[^"][^" ]*/g);
            if (invalidFields) {
                errors.push("Fields must be properly quoted");
            }
            
            // Check for command length (Windows CMD limit ~8192 chars)
            if (command.length > 8000) {
                errors.push("Command too long (may exceed system limits)");
            }
            
            return {
                isValid: errors.length === 0,
                errors: errors
            };
        }

        // File Type Optimization
        function getFileTypeCapabilities(extension) {
            const ext = extension.toLowerCase().replace('.', '');
            
            const fileTypes = {
                // Image formats with full metadata support
                'jpg': { supportsXMP: true, supportsIPTC: true, supportsEXIF: true, type: 'image' },
                'jpeg': { supportsXMP: true, supportsIPTC: true, supportsEXIF: true, type: 'image' },
                'tif': { supportsXMP: true, supportsIPTC: true, supportsEXIF: true, type: 'image' },
                'tiff': { supportsXMP: true, supportsIPTC: true, supportsEXIF: true, type: 'image' },
                'dng': { supportsXMP: true, supportsIPTC: true, supportsEXIF: true, type: 'image' },
                'png': { supportsXMP: true, supportsIPTC: false, supportsEXIF: true, type: 'image' },
                'webp': { supportsXMP: true, supportsIPTC: false, supportsEXIF: true, type: 'image' },
                'heic': { supportsXMP: true, supportsIPTC: false, supportsEXIF: true, type: 'image' },
                'gif': { supportsXMP: false, supportsIPTC: false, supportsEXIF: false, type: 'image' },
                'svg': { supportsXMP: true, supportsIPTC: false, supportsEXIF: false, type: 'image' },
                
                // Document formats
                'pdf': { supportsXMP: true, supportsIPTC: false, supportsEXIF: false, type: 'document' },
                'doc': { supportsXMP: false, supportsIPTC: false, supportsEXIF: false, type: 'document' },
                'docx': { supportsXMP: true, supportsIPTC: false, supportsEXIF: false, type: 'document' },
                'xls': { supportsXMP: false, supportsIPTC: false, supportsEXIF: false, type: 'document' },
                'xlsx': { supportsXMP: true, supportsIPTC: false, supportsEXIF: false, type: 'document' },
                'txt': { supportsXMP: false, supportsIPTC: false, supportsEXIF: false, type: 'document' },
                'rtf': { supportsXMP: false, supportsIPTC: false, supportsEXIF: false, type: 'document' },
                'html': { supportsXMP: false, supportsIPTC: false, supportsEXIF: false, type: 'document' }
            };
            
            return fileTypes[ext] || { supportsXMP: false, supportsIPTC: false, supportsEXIF: false, type: 'unknown' };
        }

        function optimizeCommandForFileType(command, extension) {
            const capabilities = getFileTypeCapabilities(extension);
            
            if (!capabilities.supportsXMP) {
                // Remove XMP fields
                command = command.replace(/-XMP[^"]*"[^"]*"\s*/g, '');
            }
            
            if (!capabilities.supportsIPTC) {
                // Remove IPTC fields
                command = command.replace(/-IPTC[^"]*"[^"]*"\s*/g, '');
            }
            
            if (!capabilities.supportsEXIF) {
                // Remove EXIF fields except basic ones
                command = command.replace(/-exif[^"]*"[^"]*"\s*/g, '');
                command = command.replace(/-IFD0[^"]*"[^"]*"\s*/g, '');
            }
            
            // For documents with limited metadata support, keep only basic fields
            if (capabilities.type === 'document' && !capabilities.supportsXMP) {
                // Keep only Title, Description, Keywords, Creator, Copyright
                const basicFields = ['-Title=', '-Description=', '-Keywords=', '-Creator=', '-Copyright='];
                const lines = command.split(' -');
                const filtered = lines.filter(line => {
                    if (!line.startsWith('-')) return true; // Keep command start
                    return basicFields.some(field => line.startsWith(field.substring(1)));
                });
                command = filtered.join(' -');
            }
            
            return command.trim();
        }

        // Generate EXIF command
        function generateExifCommand() {
            const filename = elements.generatedFilename.value;
            if (!filename) return;
            
            // Collect all people for title generation
            const people = [];
            if (elements.surname.value || elements.givenName.value) {
                people.push(`${elements.givenName.value} ${elements.middleName.value} ${elements.surname.value}`.trim());
            }
            
            // Add additional people from dynamic array
            if (elements.includeAdditionalPeople.checked && additionalPeople.length > 0) {
                additionalPeople.forEach(person => {
                    if (person.surname || person.givenName) {
                        people.push(`${person.givenName} ${person.middleName} ${person.surname}`.trim());
                    }
                });
            }
            
            const titleValue = elements.metaTitle.value || 
                `${elements.eventType.value} of ${people.filter(p => p).join(', ')}`.trim();
            
            const allKeywords = [
                elements.eventType.value,
                ...elements.place.value.split(',').map(p => p.trim()),
                elements.surname.value,
                elements.givenName.value,
                elements.middleName.value,
                elements.fileInfo.value,
                ...keywords
            ].filter(k => k && k.trim() !== '');
            
            // Add additional people keywords with contextual relationship terms
            if (elements.includeAdditionalPeople.checked && additionalPeople.length > 0) {
                // Add individual people keywords
                additionalPeople.forEach(person => {
                    if (person.surname) allKeywords.push(person.surname);
                    if (person.givenName) allKeywords.push(person.givenName);
                    if (person.middleName) allKeywords.push(person.middleName);
                    
                    // Add contextual relationship keywords for better searchability
                    if (person.relationship) {
                        allKeywords.push(person.relationship);
                        
                        // Add related family context terms
                        const relationshipContexts = {
                            'spouse': ['married couple', 'husband', 'wife', 'family'],
                            'child': ['parent and child', 'family', 'generation'],
                            'parent': ['parent and child', 'family', 'generation'],
                            'sibling': ['siblings', 'brothers', 'sisters', 'family'],
                            'witness': ['witnesses', 'ceremony', 'event'],
                            'other': ['family members', 'family']
                        };
                        
                        if (relationshipContexts[person.relationship]) {
                            allKeywords.push(...relationshipContexts[person.relationship]);
                        }
                    }
                });
                
                // Add contextual family keywords based on actual relationships
                if (people.length > 1) {
                    allKeywords.push('multiple people');
                    
                    // Determine relationship types present
                    const relationships = additionalPeople.map(p => p.relationship);
                    const hasChildren = relationships.includes('child');
                    const hasParents = relationships.includes('parent');
                    const hasSpouse = relationships.includes('spouse');
                    const hasSiblings = relationships.includes('sibling');
                    
                    // Add "family gathering" only for actual family relationships (not just spouse)
                    if (hasChildren || hasParents || hasSiblings) {
                        allKeywords.push('family gathering');
                    }
                    
                    // Add generation-specific terms only when there are actual generational differences
                    if (hasChildren && hasParents) {
                        allKeywords.push('multiple generations', 'three generations');
                    } else if (hasChildren || hasParents) {
                        allKeywords.push('multiple generations', 'two generations');
                    }
                    
                    // Spouse-specific terms (doesn't imply gathering or generations)
                    if (hasSpouse) {
                        allKeywords.push('married couple');
                    }
                }
            }
            
            let cmd = 'exiftool';
            cmd += ` -Title="${titleValue}"`;
            
            // Handle date metadata for both genealogical and precise dates
            const currentDateValue = getCurrentDateValue();
            const dateToUse = currentDateValue;
            
            if (dateToUse) {
                // Get standard datetime for DateTimeOriginal field
                const standardDate = getStandardDateFromGenealogy(dateToUse);
                if (standardDate) {
                    const formattedDate = standardDate.replace(/-/g, ':');
                    cmd += ` -DateTimeOriginal="${formattedDate} 0:0:0"`;
                }
                
                // Add genealogical date description for context preservation
                const genealogicalDate = formatGenealogyDateForMetadata(dateToUse);
                if (genealogicalDate) {
                    cmd += ` -XMP:DateDescription="${genealogicalDate}"`;
                }
            }
            
            if (elements.metaDescription.value) cmd += ` -Description="${elements.metaDescription.value}"`;
            if (elements.metaCreator.value) cmd += ` -Creator="${elements.metaCreator.value}"`;
            if (elements.metaCopyright.value) cmd += ` -Copyright="${elements.metaCopyright.value}"`;
            if (elements.metaSource.value) cmd += ` -Source="${elements.metaSource.value}"`;
            if (elements.metaNotes.value) cmd += ` -UserComment="${elements.metaNotes.value}"`;
            if (allKeywords.length > 0) cmd += ` -Keywords="${allKeywords.join(',')}"`;
            
            // Additional image metadata tags
            cmd += ` -IPTC:ObjectName="${titleValue}"`;
            
            const descriptionOrTitle = elements.metaDescription.value || titleValue;
            cmd += ` -IPTC:Caption-Abstract="${descriptionOrTitle}"`;
            cmd += ` -exif:ImageDescription="${descriptionOrTitle}"`;
            cmd += ` -IFD0:XPComment="${descriptionOrTitle}"`;
            cmd += ` -File:Comment="${descriptionOrTitle}"`;
            cmd += ` -IFD0:XPSubject="${descriptionOrTitle}"`;
            
            if (elements.eventType.value) {
                cmd += ` -xmp-iptcExt:Event="${elements.eventType.value}"`;
            }
            
            // Custom XMP metadata (keeping Repository)
            if (elements.metaRepository.value) cmd += ` -XMP-xmp:Repository="${elements.metaRepository.value}"`;
            
            // Note: Additional people are handled through the PersonInImage field below
            // which follows FHMWG standards for multiple people with semicolon separation
            
            // FHMWG metadata
            if (elements.fhmwgMetadata.checked) {
                cmd += ` -XMP:Title="${titleValue}"`;
                
                // Generate enhanced description with relationship context
                let descriptionValue = elements.metaDescription.value;
                if (!descriptionValue) {
                    let descriptionParts = [];
                    
                    // Add event and primary person
                    if (elements.eventType.value && people.filter(p => p).length > 0) {
                        descriptionParts.push(`${elements.eventType.value} of ${people[0]}`);
                    }
                    
                    // Add relationship context for additional people
                    if (elements.includeAdditionalPeople.checked && additionalPeople.length > 0) {
                        const relationshipTerms = [];
                        
                        // Process all additional people with relationship context
                        additionalPeople.forEach((person, index) => {
                            const personIndex = index + 1; // +1 because people[0] is primary person
                            if (person.surname && person.relationship && people[personIndex]) {
                                const relationshipContext = person.relationship === 'other' ? 'family member' : person.relationship;
                                relationshipTerms.push(`${relationshipContext} ${people[personIndex]}`);
                            } else if (people[personIndex]) {
                                relationshipTerms.push(people[personIndex]);
                            }
                        });
                        
                        if (relationshipTerms.length > 0) {
                            if (relationshipTerms.length === 1) {
                                descriptionParts.push(`with ${relationshipTerms[0]}`);
                            } else if (relationshipTerms.length === 2) {
                                descriptionParts.push(`with ${relationshipTerms.join(' and ')}`);
                            } else {
                                // For 3+ people, use commas and "and" for the last one
                                const lastTerm = relationshipTerms.pop();
                                descriptionParts.push(`with ${relationshipTerms.join(', ')} and ${lastTerm}`);
                            }
                        }
                    }
                    
                    // Add location context
                    if (elements.place.value) {
                        descriptionParts.push(`in ${elements.place.value}`);
                    }
                    
                    descriptionValue = descriptionParts.join(' ').trim();
                }
                
                cmd += ` -XMP:Description="${descriptionValue}"`;
                
                // Handle FHMWG date metadata
                const fhmwgDateValue = getCurrentDateValue();
                if (fhmwgDateValue) {
                    // Get standard datetime for XMP:DateCreated and IPTC:DateCreated
                    const standardDate = getStandardDateFromGenealogy(fhmwgDateValue);
                    if (standardDate) {
                        cmd += ` -XMP:DateCreated="${standardDate.replace(/-/g, ':')} 0:0:0"`;
                        cmd += ` -IPTC:DateCreated="${standardDate.replace(/-/g, '')}"`;
                    }
                    
                    // Add genealogical date description for context preservation
                    const genealogicalDate = formatGenealogyDateForMetadata(fhmwgDateValue);
                    if (genealogicalDate) {
                        cmd += ` -XMP:DateDescription="${genealogicalDate}"`;
                    }
                }
                
                if (elements.place.value) {
                    // Parse place input (smallest to largest: City, County, State, Country)
                    const placeParts = elements.place.value.split(',').map(p => p.trim());
                    
                    // Ensure we have exactly 4 parts
                    while (placeParts.length < 4) {
                        placeParts.push('');
                    }
                    
                    // Map place parts correctly
                    const city = placeParts[0] || ''; // Part 1: City
                    const county = placeParts[1] || ''; // Part 2: County
                    const state = placeParts[2] || ''; // Part 3: State
                    const country = getCountryAbbreviation(placeParts[3] || ''); // Part 4: Country (with abbreviation)
                    const sublocation = placeParts.length > 4 ? placeParts[4] : '';
                    
                    // LocationName = Full place in input order (as entered)
                    const locationName = elements.place.value;
                    
                    cmd += ` -XMP:LocationShownSublocation="${sublocation}"`;
                    cmd += ` -XMP:LocationShownCity="${city}"`;
                    cmd += ` -XMP:LocationShownLocationName="${locationName}"`;
                    cmd += ` -XMP:LocationShownProvinceState="${state}"`;
                    cmd += ` -XMP:LocationShownCountryName="${country}"`;
                    
                    cmd += ` -XMP:Location="${sublocation}"`;
                    cmd += ` -XMP:City="${city}"`;
                    cmd += ` -XMP:State="${state}"`;
                    cmd += ` -XMP:Country="${country}"`;
                    
                    cmd += ` -IPTC:Sub-location="${sublocation}"`;
                    cmd += ` -IPTC:City="${city}"`;
                    cmd += ` -IPTC:Province-State="${state}"`;
                    cmd += ` -IPTC:Country-PrimaryLocationName="${country}"`;
                }
                
                // All people in PersonInImage field
                if (people.filter(p => p).length > 0) {
                    cmd += ` -XMP:PersonInImage="${people.filter(p => p).join('; ')}"`;
                }
            }
            
            // Use actual file path if provided, otherwise use placeholder
            const finalPath = elements.filePath.value.trim() 
                ? `"${elements.filePath.value.trim()}${elements.filePath.value.trim().endsWith('\\') || elements.filePath.value.trim().endsWith('/') ? '' : (elements.filePath.value.trim().includes('\\') ? '\\' : '/')}${filename}"`
                : `"FILE_PATH_HERE\\${filename}"`;
            
            cmd += ` ${finalPath}`;
            
            // Apply file type optimization
            const fileExtension = elements.fileExtension.value;
            cmd = optimizeCommandForFileType(cmd, fileExtension);
            
            // Validate command
            const validation = validateEXIFCommand(cmd);
            
            elements.exifCommand.textContent = cmd;
            
            // Show validation status
            const commandContainer = elements.exifCommand.parentElement;
            let validationMessage = commandContainer.querySelector('.validation-message');
            
            if (!validationMessage) {
                validationMessage = document.createElement('div');
                validationMessage.className = 'validation-message mt-2';
                commandContainer.appendChild(validationMessage);
            }
            
            if (validation.isValid) {
                validationMessage.innerHTML = '<small class="text-success"><i class="bi bi-check-circle me-1"></i>Command validated successfully</small>';
            } else {
                const errorList = validation.errors.map(error => `<li>${error}</li>`).join('');
                validationMessage.innerHTML = `<small class="text-warning"><i class="bi bi-exclamation-triangle me-1"></i>Validation warnings: <ul class="mb-0 mt-1">${errorList}</ul></small>`;
            }
            
            // Update warning message based on whether file path is provided
            const pathWarning = document.getElementById('pathWarning');
            if (pathWarning) {
                const alertDiv = pathWarning.parentElement;
                if (elements.filePath.value.trim()) {
                    alertDiv.className = 'alert alert-success';
                    alertDiv.innerHTML = '<i class="bi bi-check-circle me-2"></i>Using specified file path: <strong>' + elements.filePath.value.trim() + '</strong>';
                } else {
                    alertDiv.className = 'alert alert-warning';
                    alertDiv.innerHTML = '<i class="bi bi-exclamation-triangle me-2"></i><span id="pathWarning">Replace <strong>FILE_PATH_HERE</strong> with your directory path, or use the File Path field above. The command already includes the filename at the end.</span>';
                }
            }
        }

        // Toggle metadata section
        function toggleMetadataSection() {
            const section = elements.metadataSection;
            const button = elements.toggleMetadata;
            const icon = button.querySelector('i');
            
            if (section.classList.contains('hidden')) {
                section.classList.remove('hidden');
                button.innerHTML = 'Hide Metadata Options <i class="bi bi-chevron-up"></i>';
            } else {
                section.classList.add('hidden');
                button.innerHTML = 'Customize Metadata <i class="bi bi-chevron-down"></i>';
            }
        }

        // Toggle reference section
        function toggleReferenceSection() {
            const section = elements.referenceSection;
            const button = elements.toggleReference;
            
            if (section.classList.contains('hidden')) {
                section.classList.remove('hidden');
                button.innerHTML = '<i class="bi bi-info-circle me-1"></i>Reference <i class="bi bi-chevron-up"></i>';
            } else {
                section.classList.add('hidden');
                button.innerHTML = '<i class="bi bi-info-circle me-1"></i>Reference <i class="bi bi-chevron-down"></i>';
            }
        }

        // Clear form
        function clearForm() {
            elements.eventType.value = '';
            elements.place.value = '';
            elements.placeFormat.value = 'usa';
            updatePlaceFormatUI();
            // Legacy date element removed
            elements.genealogyDate.value = '';
            elements.preciseDate.value = '';
            elements.dateValidation.style.display = 'none';
            elements.genealogyDate.classList.remove('is-invalid', 'is-valid');
            elements.surname.value = '';
            elements.givenName.value = '';
            elements.middleName.value = '';
            elements.fileInfo.value = '';
            elements.fileExtension.value = '.jpg';
            // NOTE: File Path is intentionally NOT cleared to remain "sticky" between entries
            elements.metaTitle.value = '';
            elements.metaDescription.value = '';
            elements.metaCreator.value = '';
            elements.metaCopyright.value = '';
            elements.metaSource.value = '';
            elements.metaRepository.value = '';
            elements.metaNotes.value = '';
            keywords = [];
            updateKeywordsDisplay();
            
            // Clear additional people fields
            elements.includeAdditionalPeople.checked = false;
            elements.additionalPeopleSection.classList.add('hidden');
            elements.nameFormatInput.value = '{GIVEN}.{SURNAME}|+';
            clearAllAdditionalPeople();
            
            Object.values(suggestions).forEach(container => {
                if (container) { // Check for null elements
                    container.classList.add('hidden');
                }
            });
            
            activeIndex = -1;
            activeDropdown = null;
            generateFilename();
            
            // Note: We intentionally don't clear the GEDCOM file here
            // as users typically want to keep it loaded while clearing form data
        }

        // Copy functions with fallback
        function copyToClipboard(text) {
            // Try modern clipboard API first
            if (navigator.clipboard && navigator.clipboard.writeText) {
                return navigator.clipboard.writeText(text);
            } else {
                // Fallback for older browsers or insecure contexts
                return new Promise((resolve, reject) => {
                    const textArea = document.createElement('textarea');
                    textArea.value = text;
                    textArea.style.position = 'fixed';
                    textArea.style.left = '-999999px';
                    textArea.style.top = '-999999px';
                    document.body.appendChild(textArea);
                    textArea.focus();
                    textArea.select();
                    
                    try {
                        const result = document.execCommand('copy');
                        document.body.removeChild(textArea);
                        if (result) {
                            resolve();
                        } else {
                            reject(new Error('Copy command failed'));
                        }
                    } catch (err) {
                        document.body.removeChild(textArea);
                        reject(err);
                    }
                });
            }
        }

        function copyFilename() {
            copyToClipboard(elements.generatedFilename.value)
                .then(() => {
                    const button = document.getElementById('copyFilenameText');
                    button.textContent = 'Copied!';
                    setTimeout(() => {
                        button.textContent = 'Copy';
                    }, 2000);
                })
                .catch((err) => {
                    console.error('Failed to copy filename:', err);
                    alert('Failed to copy to clipboard. Please select and copy manually.');
                });
        }

        function copyCommand() {
            copyToClipboard(elements.exifCommand.textContent)
                .then(() => {
                    const button = document.getElementById('copyCommandText');
                    button.textContent = 'Copied!';
                    setTimeout(() => {
                        button.textContent = 'Copy';
                    }, 2000);
                })
                .catch((err) => {
                    console.error('Failed to copy command:', err);
                    alert('Failed to copy to clipboard. Please select and copy manually.');
                });
        }

        // Keyword management
        function addKeyword() {
            const keyword = elements.keywordInput.value.trim();
            if (keyword && !keywords.includes(keyword)) {
                keywords.push(keyword);
                elements.keywordInput.value = '';
                updateKeywordsDisplay();
                generateExifCommand();
            }
        }

        function removeKeyword(keyword) {
            keywords = keywords.filter(k => k !== keyword);
            updateKeywordsDisplay();
            generateExifCommand();
        }

        function updateKeywordsDisplay() {
            const container = elements.keywordsContainer;
            container.innerHTML = '';
            
            keywords.forEach(keyword => {
                const tag = document.createElement('span');
                tag.className = 'keyword-tag';
                
                const text = document.createElement('span');
                text.textContent = keyword;
                
                const removeBtn = document.createElement('button');
                removeBtn.className = 'keyword-remove';
                removeBtn.textContent = '×';
                removeBtn.addEventListener('click', () => removeKeyword(keyword));
                
                tag.appendChild(text);
                tag.appendChild(removeBtn);
                container.appendChild(tag);
            });
        }

        // Click outside to close suggestions
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.form-field')) {
                // Close static suggestions
                Object.values(suggestions).forEach(container => {
                    if (container) { // Check for null elements
                        container.classList.add('hidden');
                    }
                });
                activeIndex = -1;
                
                // Close dynamic person suggestions
                const dynamicSuggestions = document.querySelectorAll('.person-suggestions');
                dynamicSuggestions.forEach(container => {
                    container.classList.add('hidden');
                });
            }
        });

        // ============================================================================
        // GEDCOM SUGGESTION UI FUNCTIONALITY
        // ============================================================================
        
        // Update contextual suggestions based on form input
        function updateContextualSuggestions() {
            if (!gedcomIndividuals.length) {
                elements.gedcomSuggestionsSection.classList.add('hidden');
                return;
            }
            
            const eventType = elements.eventType.value.trim();
            const surname = elements.surname.value.trim();
            const givenName = elements.givenName.value.trim();
            const middleName = elements.middleName.value.trim();
            const date = elements.genealogyDate.value.trim();
            
            if (!eventType || !surname) {
                elements.gedcomSuggestionsSection.classList.add('hidden');
                return;
            }
            
            const primaryPersonData = { surname, givenName, middleName };
            const analysis = analyzeDocumentContext(eventType, primaryPersonData);
            
            if (analysis.context === 'suggestions-available' && analysis.suggestions.length > 0) {
                let chronologicalSuggestions = analysis.suggestions;
                if (date) {
                    chronologicalSuggestions = validateChronologicalAppropiateness(analysis.suggestions, date);
                }
                
                if (chronologicalSuggestions.length > 0) {
                    renderSuggestionButtons(chronologicalSuggestions);
                    elements.gedcomSuggestionsSection.classList.remove('hidden');
                } else {
                    elements.gedcomSuggestionsSection.classList.add('hidden');
                }
            } else {
                elements.gedcomSuggestionsSection.classList.add('hidden');
            }
        }
        
        // Render suggestion buttons in the UI
        function renderSuggestionButtons(suggestions) {
            const container = elements.relationshipSuggestions;
            container.innerHTML = '';
            
            suggestions.forEach(suggestion => {
                const button = document.createElement('button');
                button.type = 'button';
                button.className = 'btn suggestion-button';
                
                const person = suggestion.person;
                const displayName = formatPersonName(person.name);
                const confidencePercent = Math.round(suggestion.confidence * 100);
                
                button.innerHTML = `
                    <div>
                        <i class="bi bi-person-plus me-1"></i>
                        <strong>${displayName}</strong>
                        <span class="suggestion-confidence">(${confidencePercent}%)</span>
                    </div>
                    <div class="suggestion-reason">${suggestion.reason}</div>
                `;
                
                button.addEventListener('click', () => {
                    applySuggestion(suggestion);
                });
                
                container.appendChild(button);
            });
        }
        
        // Format person name for display
        function formatPersonName(name) {
            if (name.full) return name.full;
            
            const parts = [];
            if (name.given) parts.push(name.given);
            if (name.middle) parts.push(name.middle);
            if (name.surname) parts.push(name.surname.toUpperCase());
            
            return parts.join(' ') || 'Unknown Name';
        }
        
        // Apply a suggestion to add a person
        function applySuggestion(suggestion) {
            const person = suggestion.person;
            const name = person.name;
            
            // Ensure additional people section is visible
            if (!elements.includeAdditionalPeople.checked) {
                elements.includeAdditionalPeople.checked = true;
                toggleAdditionalPeople();
            }
            
            // Create new person data
            const personData = {
                id: 'person' + personIdCounter++,
                surname: name.surname || '',
                givenName: name.given || '',
                middleName: name.middle || '',
                relationship: suggestion.relationship
            };
            
            // Add to additional people array and render
            additionalPeople.push(personData);
            renderPersonRow(personData);
            generateFilename();

            // Update suggestions to hide applied suggestion
            setTimeout(updateContextualSuggestions, 100);
        }
        
        // Update family tree insights panel
        function updateFamilyInsights() {
            const insights = getFamilyTreeInsights();
            
            if (!insights) {
                elements.familyInsightsPanel.classList.add('hidden');
                return;
            }
            
            // Show insights panel
            elements.familyInsightsPanel.classList.remove('hidden');
            
            // Update statistics
            elements.totalIndividuals.textContent = insights.totalIndividuals.toLocaleString();
            elements.namedIndividuals.textContent = insights.namedIndividuals.toLocaleString();
            
            // Update date range
            if (insights.dateRange.earliest && insights.dateRange.latest) {
                elements.dateRangeValue.textContent = `${insights.dateRange.earliest}-${insights.dateRange.latest}`;
            } else {
                elements.dateRangeValue.textContent = 'Not available';
            }
            
            // Update relationship coverage
            elements.relationshipCoverage.textContent = `${insights.relationshipCoverage}%`;
            
            // Update data quality
            const quality = insights.dataQuality;
            elements.qualityFill.style.width = `${quality.score}%`;
            elements.qualityScore.textContent = `${quality.score}% complete`;
            
            // Update surname list
            elements.surnameList.innerHTML = '';
            insights.topSurnames.forEach(([surname, count]) => {
                const tag = document.createElement('span');
                tag.className = 'surname-tag';
                tag.textContent = `${surname} (${count})`;
                elements.surnameList.appendChild(tag);
            });
        }
        
        // Toggle insights panel visibility
        function toggleInsightsPanel() {
            const isHidden = elements.insightsContent.classList.contains('hidden');
            elements.insightsContent.classList.toggle('hidden', !isHidden);
            elements.insightsChevron.classList.toggle('bi-chevron-down', !isHidden);
            elements.insightsChevron.classList.toggle('bi-chevron-up', isHidden);
        }
        
        // Add event listeners for suggestion triggers
        function initializeSuggestionTriggers() {
            // Trigger suggestions when key fields change
            const suggestionTriggers = [
                elements.eventType,
                elements.surname,
                elements.givenName,
                elements.middleName,
                elements.genealogyDate
            ];
            
            suggestionTriggers.forEach(element => {
                if (element) {
                    element.addEventListener('input', debounce(updateContextualSuggestions, 300));
                    element.addEventListener('change', updateContextualSuggestions);
                }
            });
            
            // Insights panel toggle
            if (elements.insightsToggle) {
                elements.insightsToggle.addEventListener('click', toggleInsightsPanel);
            }
        }
        
        // ============================================================================
        // RELATIONSHIP-SPECIFIC SUGGESTION FUNCTIONALITY
        // ============================================================================
        
        // Get relationship-specific suggestions for a person
        function getRelationshipSpecificSuggestions(primaryPersonData, relationshipType) {
            console.log('getRelationshipSpecificSuggestions called with:', primaryPersonData, relationshipType);
            
            if (!primaryPersonData || !relationshipType || gedcomIndividuals.length === 0) {
                console.log('Early return - missing data');
                return [];
            }
            
            // Find primary person in GEDCOM data
            const primaryMatches = findPersonByName(
                primaryPersonData.surname || '',
                primaryPersonData.givenName || '',
                primaryPersonData.middleName || ''
            );
            
            console.log('Primary person matches found:', primaryMatches.length);
            
            if (primaryMatches.length === 0) {
                console.log('No primary person matches found');
                return [];
            }
            
            const primaryPerson = primaryMatches[0].individual;
            console.log('Primary person found:', primaryPerson.name, 'ID:', primaryPerson.id);
            
            const relationships = getRelationships(primaryPerson.id);
            console.log('All relationships for primary person:', relationships.length);
            console.log('Relationships details:', relationships);
            
            // Filter relationships by type
            const filteredRelationships = relationships.filter(rel => 
                rel.relationshipType === relationshipType
            );
            console.log(`Filtered relationships for type '${relationshipType}':`, filteredRelationships.length);
            
            // Convert to suggestion format
            const suggestions = filteredRelationships.map(rel => {
                const relatedPerson = gedcomIndividuals.find(p => p.id === rel.relatedPersonId);
                if (relatedPerson && relatedPerson.name) {
                    return {
                        person: relatedPerson,
                        relationship: relationshipType,
                        confidence: rel.confidence,
                        reason: `${relationshipType.charAt(0).toUpperCase() + relationshipType.slice(1)} relationship from family tree`
                    };
                }
                return null;
            }).filter(Boolean);
            
            // Sort by confidence and return high-confidence suggestions
            return suggestions
                .sort((a, b) => b.confidence - a.confidence)
                .filter(s => s.confidence >= 0.7); // Higher threshold for specific relationship suggestions
        }
        
        // Update relationship-specific suggestions when relationship changes
        function updateRelationshipSpecificSuggestions() {
            console.log('updateRelationshipSpecificSuggestions called');
            
            // Get current primary person data
            const surname = elements.surname.value.trim();
            const givenName = elements.givenName.value.trim();
            const middleName = elements.middleName.value.trim();
            
            console.log('Primary person data:', { surname, givenName, middleName });
            console.log('GEDCOM individuals count:', gedcomIndividuals.length);
            
            if (!surname || gedcomIndividuals.length === 0) {
                console.log('Hiding suggestions - missing surname or no GEDCOM data');
                elements.relationshipSpecificSuggestions.classList.add('hidden');
                return;
            }
            
            // Find the active relationship dropdown (if any)
            const activePersonRows = document.querySelectorAll('.additional-person-row');
            console.log('Active person rows:', activePersonRows.length);
            
            if (activePersonRows.length === 0) {
                console.log('No active person rows found');
                elements.relationshipSpecificSuggestions.classList.add('hidden');
                return;
            }
            
            // Get the relationship type from the last added person (most recent)
            const lastPersonRow = activePersonRows[activePersonRows.length - 1];
            const relationshipSelect = lastPersonRow.querySelector('.person-relationship');
            
            if (!relationshipSelect) {
                console.log('No relationship select found');
                elements.relationshipSpecificSuggestions.classList.add('hidden');
                return;
            }
            
            const selectedRelationship = relationshipSelect.value;
            console.log('Selected relationship:', selectedRelationship);
            
            const primaryPersonData = { surname, givenName, middleName };
            
            const suggestions = getRelationshipSpecificSuggestions(primaryPersonData, selectedRelationship);
            console.log('Generated suggestions:', suggestions.length);
            
            if (suggestions.length > 0) {
                console.log('Showing suggestions for relationship:', selectedRelationship);
                renderRelationshipSpecificSuggestions(suggestions, selectedRelationship);
                elements.relationshipSpecificSuggestions.classList.remove('hidden');
            } else {
                console.log('No suggestions found, hiding panel');
                elements.relationshipSpecificSuggestions.classList.add('hidden');
            }
        }
        
        // Render relationship-specific suggestion buttons
        function renderRelationshipSpecificSuggestions(suggestions, relationshipType) {
            const container = elements.relationshipFilteredSuggestions;
            const title = elements.relationshipSuggestionsTitle;
            
            // Update title based on relationship type
            const relationshipTitles = {
                'spouse': 'Suggested Spouses',
                'child': 'Suggested Children', 
                'parent': 'Suggested Parents',
                'sibling': 'Suggested Siblings',
                'witness': 'Suggested Witnesses',
                'other': 'Suggested People'
            };
            
            title.textContent = relationshipTitles[relationshipType] || 'Suggested People';
            
            // Clear existing suggestions
            container.innerHTML = '';
            
            suggestions.forEach(suggestion => {
                const button = document.createElement('button');
                button.type = 'button';
                button.className = 'btn suggestion-button';
                
                const person = suggestion.person;
                const displayName = formatPersonName(person.name);
                const confidencePercent = Math.round(suggestion.confidence * 100);
                
                button.innerHTML = `
                    <div>
                        <i class="bi bi-person-plus me-1"></i>
                        <strong>${displayName}</strong>
                        <span class="suggestion-confidence">(${confidencePercent}%)</span>
                    </div>
                    <div class="suggestion-reason">${suggestion.reason}</div>
                `;
                
                button.addEventListener('click', () => {
                    applyRelationshipSpecificSuggestion(suggestion);
                });
                
                container.appendChild(button);
            });
        }
        
        // Apply a relationship-specific suggestion to the current person form
        function applyRelationshipSpecificSuggestion(suggestion) {
            const person = suggestion.person;
            const name = person.name;
            
            console.log('Applying suggestion for person:', person);
            console.log('Name object:', name);
            console.log('Name properties - surname:', name.surname, 'given:', name.given, 'middle:', name.middle);
            
            // Find the last person row (the one we're suggesting for)
            const activePersonRows = document.querySelectorAll('.additional-person-row');
            if (activePersonRows.length === 0) return;
            
            const lastPersonRow = activePersonRows[activePersonRows.length - 1];
            const personId = lastPersonRow.getAttribute('data-person-id');
            
            // Update the person data with suggested information
            const surnameInput = lastPersonRow.querySelector('.person-surname');
            const givenNameInput = lastPersonRow.querySelector('.person-given');
            const middleNameInput = lastPersonRow.querySelector('.person-middle');
            
            console.log('Input elements found:');
            console.log('- surnameInput:', !!surnameInput);
            console.log('- givenNameInput:', !!givenNameInput);
            console.log('- middleNameInput:', !!middleNameInput);
            
            if (surnameInput) {
                surnameInput.value = name.surname || '';
                updatePersonData(personId, 'surname', name.surname || '');
                console.log('Set surname to:', name.surname);
            }
            
            if (givenNameInput) {
                givenNameInput.value = name.given || '';
                updatePersonData(personId, 'givenName', name.given || '');
                console.log('Set given name to:', name.given);
            }
            
            if (middleNameInput) {
                middleNameInput.value = name.middle || '';
                updatePersonData(personId, 'middleName', name.middle || '');
                console.log('Set middle name to:', name.middle);
            }
            
            // Update filename
            generateFilename();
            
            // Hide suggestions after applying
            elements.relationshipSpecificSuggestions.classList.add('hidden');
        }
        
        // Debounce function to limit suggestion updates
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }
        
        // Function to show file loaded indicator and update insights
        function showFileLoadedIndicator(filename) {
            // Hide upload zone and show file loaded indicator
            elements.uploadZone.classList.add('hidden');
            elements.fileLoadedIndicator.classList.remove('hidden');
            elements.loadedFilename.textContent = filename;
            updateFamilyInsights();
        }

        // ============================================================
        // SETTINGS FUNCTIONS (Story 2: Settings UI & LocalStorage)
        // ============================================================

        // Load settings from localStorage
        function loadSettings() {
            try {
                const stored = localStorage.getItem(SETTINGS_STORAGE_KEY);
                if (stored) {
                    const parsed = JSON.parse(stored);
                    userSettings = { ...userSettings, ...parsed };

                    // Populate template input if custom template exists
                    if (userSettings.filenameTemplate && elements.filenameTemplate) {
                        elements.filenameTemplate.value = userSettings.filenameTemplate;
                    }

                    // Story 1.3: Populate dateSubtemplate input if exists
                    if (userSettings.dateSubtemplate && elements.dateSubtemplateInput) {
                        elements.dateSubtemplateInput.value = userSettings.dateSubtemplate;
                    }

                    // Story 1.4: Populate placeSubtemplate input if exists
                    if (userSettings.placeSubtemplate && elements.placeSubtemplateInput) {
                        elements.placeSubtemplateInput.value = userSettings.placeSubtemplate;
                    }

                    // Story 1.5: Populate nameSubtemplate input if exists
                    if (userSettings.nameSubtemplate && elements.nameSubtemplateInput) {
                        elements.nameSubtemplateInput.value = userSettings.nameSubtemplate;
                    }

                    // Story 4: Populate nameFormat input if exists
                    if (userSettings.nameFormat && elements.nameFormatInput) {
                        elements.nameFormatInput.value = userSettings.nameFormat;
                    }

                    // Populate filePath input if exists
                    if (userSettings.filePath && elements.filePath) {
                        elements.filePath.value = userSettings.filePath;
                    }

                    // Update preview
                    updateTemplatePreview();
                }
            } catch (error) {
                console.warn('Failed to load settings from localStorage:', error.message);
                // Use defaults on error - no action needed
            }
        }

        // Save settings to localStorage with debouncing
        function saveSettings() {
            // Clear existing timeout
            clearTimeout(saveSettingsTimeout);

            // Set new timeout for debounced save
            saveSettingsTimeout = setTimeout(() => {
                try {
                    // Update userSettings object
                    userSettings.filenameTemplate = elements.filenameTemplate.value.trim();
                    userSettings.dateSubtemplate = elements.dateSubtemplateInput.value.trim() || '{YYYY}.{MM}.{DD}';  // Story 1.3
                    userSettings.placeSubtemplate = elements.placeSubtemplateInput.value.trim() || '{COUNTRY}.{STATE}.{COUNTY}.{CITY}';  // Story 1.4
                    userSettings.nameSubtemplate = elements.nameSubtemplateInput.value.trim() || '{SURNAME:upper}.{GIVEN}';  // Story 1.5
                    userSettings.nameFormat = elements.nameFormatInput.value.trim() || '{GIVEN}.{SURNAME}|+';
                    userSettings.filePath = elements.filePath.value.trim();
                    userSettings.useCustomTemplate = userSettings.filenameTemplate.length > 0;
                    userSettings.lastUpdated = new Date().toISOString();

                    // Save to localStorage
                    localStorage.setItem(SETTINGS_STORAGE_KEY, JSON.stringify(userSettings));

                    // Update preview to show current template result
                    updateTemplatePreview();

                    // Show save indicator
                    showSaveIndicator();
                } catch (error) {
                    console.warn('Failed to save settings to localStorage:', error.message);
                }
            }, 500); // 500ms debounce delay
        }

        // Reset template to default
        function resetTemplate() {
            try {
                // Clear template input
                elements.filenameTemplate.value = '';

                // Story 4: Reset nameFormat to default
                elements.nameFormatInput.value = '{GIVEN}.{SURNAME}|+';

                // Update userSettings
                userSettings.filenameTemplate = '';
                userSettings.nameFormat = '{GIVEN}.{SURNAME}|+';
                userSettings.useCustomTemplate = false;
                userSettings.lastUpdated = new Date().toISOString();

                // Save to localStorage
                localStorage.setItem(SETTINGS_STORAGE_KEY, JSON.stringify(userSettings));

                // Update preview
                updateTemplatePreview();

                // Show confirmation via save indicator
                showSaveIndicator();
            } catch (error) {
                console.warn('Failed to reset template:', error.message);
            }
        }

        // Show save indicator with visual feedback
        function showSaveIndicator() {
            const indicator = elements.settingsSaveIndicator;

            // Update text and style
            indicator.innerHTML = '<i class="bi bi-cloud-check me-1"></i>Settings auto-saved';
            indicator.classList.remove('text-muted');
            indicator.classList.add('text-success');

            // Fade back to muted after 2 seconds
            setTimeout(() => {
                indicator.innerHTML = '<i class="bi bi-cloud-check me-1"></i>Ready';
                indicator.classList.remove('text-success');
                indicator.classList.add('text-muted');
            }, 2000);
        }

        // Update template preview (stub for Story 2, full implementation in Story 3)
        function updateTemplatePreview() {
            const preview = elements.templatePreview;
            const template = elements.filenameTemplate.value.trim();

            // Reset classes
            preview.classList.remove('text-muted', 'text-danger');

            if (template.length === 0) {
                preview.textContent = 'Using default format';
                preview.classList.add('text-muted');
            } else {
                try {
                    // Parse the template and display the result
                    const result = parseFilenameTemplate(template);
                    preview.textContent = result;
                } catch (error) {
                    // Display error if parsing fails
                    preview.textContent = '⚠ Invalid template format';
                    preview.classList.add('text-danger');
                }
            }
        }

        // ============================================================================
        // TEST SUITE FOR processSubTemplate() - Story 1.1
        // ============================================================================
        // Comprehensive unit tests validating all acceptance criteria.

        function runProcessSubTemplateTests() {
            console.log('\n=== Running processSubTemplate() Test Suite ===\n');

            const tests = [];
            let passCount = 0;
            let failCount = 0;

            // Test 1: Basic placeholder replacement (AC #1)
            try {
                const result = processSubTemplate('{YYYY}.{MM}.{DD}', {
                    year: 2024,
                    month: 3,
                    day: 15
                });
                const expected = '2024.03.15';
                if (result === expected) {
                    console.log('✓ Test 1 PASS: Basic placeholder replacement');
                    console.log(`  Input: "{YYYY}.{MM}.{DD}" → Output: "${result}"`);
                    passCount++;
                } else {
                    console.error(`✗ Test 1 FAIL: Expected "${expected}", got "${result}"`);
                    failCount++;
                }
            } catch (e) {
                console.error('✗ Test 1 ERROR:', e.message);
                failCount++;
            }

            // Test 2: Missing data handling (AC #2)
            try {
                const result = processSubTemplate('{YYYY}.{MM}.{DD}', { year: 2024 });
                const expected = '2024.x.x';
                if (result === expected) {
                    console.log('✓ Test 2 PASS: Missing data handling');
                    console.log(`  Input: partial data → Output: "${result}"`);
                    passCount++;
                } else {
                    console.error(`✗ Test 2 FAIL: Expected "${expected}", got "${result}"`);
                    failCount++;
                }
            } catch (e) {
                console.error('✗ Test 2 ERROR:', e.message);
                failCount++;
            }

            // Test 3: Padding rules - MM with single digit (AC #3)
            try {
                const result = processSubTemplate('{MM}', { month: 3 });
                const expected = '03';
                if (result === expected) {
                    console.log('✓ Test 3 PASS: Padding rules for MM');
                    console.log(`  Input: month=3 → Output: "${result}"`);
                    passCount++;
                } else {
                    console.error(`✗ Test 3 FAIL: Expected "${expected}", got "${result}"`);
                    failCount++;
                }
            } catch (e) {
                console.error('✗ Test 3 ERROR:', e.message);
                failCount++;
            }

            // Test 4: Padding rules - M without padding (AC #3)
            try {
                const result = processSubTemplate('{M}', { month: 3 });
                const expected = '3';
                if (result === expected) {
                    console.log('✓ Test 4 PASS: No padding for single-letter placeholders');
                    console.log(`  Input: {M} month=3 → Output: "${result}"`);
                    passCount++;
                } else {
                    console.error(`✗ Test 4 FAIL: Expected "${expected}", got "${result}"`);
                    failCount++;
                }
            } catch (e) {
                console.error('✗ Test 4 ERROR:', e.message);
                failCount++;
            }

            // Test 5: Year abbreviation (AC #3)
            try {
                const result = processSubTemplate('{YY}', { year: 2024 });
                const expected = '24';
                if (result === expected) {
                    console.log('✓ Test 5 PASS: Year abbreviation YY');
                    console.log(`  Input: year=2024 → Output: "${result}"`);
                    passCount++;
                } else {
                    console.error(`✗ Test 5 FAIL: Expected "${expected}", got "${result}"`);
                    failCount++;
                }
            } catch (e) {
                console.error('✗ Test 5 ERROR:', e.message);
                failCount++;
            }

            // Test 6: Format modifier :upper (AC #1)
            try {
                const result = processSubTemplate('{GIVEN:upper}', { given: 'john' });
                const expected = 'JOHN';
                if (result === expected) {
                    console.log('✓ Test 6 PASS: Format modifier :upper');
                    console.log(`  Input: {GIVEN:upper} given=john → Output: "${result}"`);
                    passCount++;
                } else {
                    console.error(`✗ Test 6 FAIL: Expected "${expected}", got "${result}"`);
                    failCount++;
                }
            } catch (e) {
                console.error('✗ Test 6 ERROR:', e.message);
                failCount++;
            }

            // Test 7: Format modifier :lower
            try {
                const result = processSubTemplate('{SURNAME:lower}', { surname: 'SMITH' });
                const expected = 'smith';
                if (result === expected) {
                    console.log('✓ Test 7 PASS: Format modifier :lower');
                    console.log(`  Input: {SURNAME:lower} surname=SMITH → Output: "${result}"`);
                    passCount++;
                } else {
                    console.error(`✗ Test 7 FAIL: Expected "${expected}", got "${result}"`);
                    failCount++;
                }
            } catch (e) {
                console.error('✗ Test 7 ERROR:', e.message);
                failCount++;
            }

            // Test 8: Format modifier :title
            try {
                const result = processSubTemplate('{GIVEN:title}', { given: 'john william' });
                const expected = 'John William';
                if (result === expected) {
                    console.log('✓ Test 8 PASS: Format modifier :title');
                    console.log(`  Input: {GIVEN:title} → Output: "${result}"`);
                    passCount++;
                } else {
                    console.error(`✗ Test 8 FAIL: Expected "${expected}", got "${result}"`);
                    failCount++;
                }
            } catch (e) {
                console.error('✗ Test 8 ERROR:', e.message);
                failCount++;
            }

            // Test 9: Format modifier :abbrev
            try {
                const result = processSubTemplate('{GIVEN:abbrev}', { given: 'john' });
                const expected = 'J';
                if (result === expected) {
                    console.log('✓ Test 9 PASS: Format modifier :abbrev');
                    console.log(`  Input: {GIVEN:abbrev} → Output: "${result}"`);
                    passCount++;
                } else {
                    console.error(`✗ Test 9 FAIL: Expected "${expected}", got "${result}"`);
                    failCount++;
                }
            } catch (e) {
                console.error('✗ Test 9 ERROR:', e.message);
                failCount++;
            }

            // Test 10: Performance - single execution (AC #5)
            try {
                const start = performance.now();
                processSubTemplate('{YYYY}.{MM}.{DD}', { year: 2024, month: 3, day: 15 });
                const duration = performance.now() - start;
                if (duration < 5) {
                    console.log(`✓ Test 10 PASS: Single execution performance`);
                    console.log(`  Duration: ${duration.toFixed(3)}ms (target <5ms)`);
                    passCount++;
                } else {
                    console.warn(`⚠ Test 10 WARNING: Performance ${duration.toFixed(3)}ms (target <5ms)`);
                    passCount++; // Still pass, but warn
                }
            } catch (e) {
                console.error('✗ Test 10 ERROR:', e.message);
                failCount++;
            }

            // Test 11: Performance - 1000 iterations (AC #5)
            try {
                const iterStart = performance.now();
                for (let i = 0; i < 1000; i++) {
                    processSubTemplate('{YYYY}.{MM}.{DD}', { year: 2024, month: 3, day: 15 });
                }
                const iterDuration = performance.now() - iterStart;
                if (iterDuration < 5000) {
                    console.log(`✓ Test 11 PASS: 1000 iterations performance`);
                    console.log(`  Duration: ${iterDuration.toFixed(2)}ms (target <5000ms)`);
                    passCount++;
                } else {
                    console.warn(`⚠ Test 11 WARNING: 1000 iterations ${iterDuration.toFixed(2)}ms (target <5000ms)`);
                    passCount++; // Still pass, but warn
                }
            } catch (e) {
                console.error('✗ Test 11 ERROR:', e.message);
                failCount++;
            }

            // Test 12: Deterministic output (AC #6)
            try {
                const input = { year: 2024, month: 3, day: 15 };
                const template = '{YYYY}.{MM}.{DD}';
                const results = [];
                for (let i = 0; i < 5; i++) {
                    results.push(processSubTemplate(template, input));
                }
                const allSame = results.every(r => r === results[0]);
                if (allSame) {
                    console.log('✓ Test 12 PASS: Deterministic output');
                    console.log(`  5 identical runs: all returned "${results[0]}"`);
                    passCount++;
                } else {
                    console.error(`✗ Test 12 FAIL: Non-deterministic results:`, results);
                    failCount++;
                }
            } catch (e) {
                console.error('✗ Test 12 ERROR:', e.message);
                failCount++;
            }

            // Test 13: Malformed placeholder handling (AC #7) - console.warn() should be called
            try {
                const originalWarn = console.warn;
                let warnCalled = false;
                console.warn = function() { warnCalled = true; originalWarn.apply(console, arguments); };

                const result = processSubTemplate('{YYYYY}', { year: 2024 });

                console.warn = originalWarn;

                // Should preserve the placeholder and log warning
                if (result === '{YYYYY}' && warnCalled) {
                    console.log('✓ Test 13 PASS: Malformed placeholder handling');
                    console.log(`  Invalid placeholder preserved: "${result}"`);
                    passCount++;
                } else {
                    console.error(`✗ Test 13 FAIL: Invalid placeholder not handled correctly`);
                    failCount++;
                }
            } catch (e) {
                console.error('✗ Test 13 ERROR:', e.message);
                failCount++;
            }

            // Test 14: Null value handling (AC #2)
            try {
                const result = processSubTemplate('{MM}', { month: null });
                const expected = 'x';
                if (result === expected) {
                    console.log('✓ Test 14 PASS: Null value handling');
                    console.log(`  month=null → Output: "${result}"`);
                    passCount++;
                } else {
                    console.error(`✗ Test 14 FAIL: Expected "${expected}", got "${result}"`);
                    failCount++;
                }
            } catch (e) {
                console.error('✗ Test 14 ERROR:', e.message);
                failCount++;
            }

            // Test 15: Zero value handling (AC #2) - zero should NOT be treated as missing
            try {
                const result = processSubTemplate('{MM}', { month: 0 });
                const expected = '00';
                if (result === expected) {
                    console.log('✓ Test 15 PASS: Zero value handling');
                    console.log(`  month=0 → Output: "${result}" (zero is valid, not missing)`);
                    passCount++;
                } else {
                    console.error(`✗ Test 15 FAIL: Expected "${expected}", got "${result}"`);
                    failCount++;
                }
            } catch (e) {
                console.error('✗ Test 15 ERROR:', e.message);
                failCount++;
            }

            // Test 16: Empty string handling (AC #2)
            try {
                const result = processSubTemplate('{GIVEN}', { given: '' });
                const expected = 'x';
                if (result === expected) {
                    console.log('✓ Test 16 PASS: Empty string handling');
                    console.log(`  given="" → Output: "${result}"`);
                    passCount++;
                } else {
                    console.error(`✗ Test 16 FAIL: Expected "${expected}", got "${result}"`);
                    failCount++;
                }
            } catch (e) {
                console.error('✗ Test 16 ERROR:', e.message);
                failCount++;
            }

            // Test 17: Place placeholders
            try {
                const result = processSubTemplate('{COUNTRY}.{STATE}.{CITY}', {
                    country: 'USA',
                    state: 'California',
                    city: 'San Francisco'
                });
                const expected = 'USA.California.San Francisco';
                if (result === expected) {
                    console.log('✓ Test 17 PASS: Place placeholders');
                    console.log(`  PLACE template → Output: "${result}"`);
                    passCount++;
                } else {
                    console.error(`✗ Test 17 FAIL: Expected "${expected}", got "${result}"`);
                    failCount++;
                }
            } catch (e) {
                console.error('✗ Test 17 ERROR:', e.message);
                failCount++;
            }

            // Test 18: Abbreviated place placeholders
            try {
                const result = processSubTemplate('{C}.{S}.{CI}', {
                    country: 'USA',
                    state: 'NY',
                    city: 'New York'
                });
                const expected = 'USA.NY.New York';
                if (result === expected) {
                    console.log('✓ Test 18 PASS: Abbreviated place placeholders');
                    console.log(`  Abbrev placeholders → Output: "${result}"`);
                    passCount++;
                } else {
                    console.error(`✗ Test 18 FAIL: Expected "${expected}", got "${result}"`);
                    failCount++;
                }
            } catch (e) {
                console.error('✗ Test 18 ERROR:', e.message);
                failCount++;
            }

            // Test 19: Name placeholders
            try {
                const result = processSubTemplate('{SURNAME}.{GIVEN}.{MIDDLE}', {
                    surname: 'Smith',
                    given: 'John',
                    middle: 'William'
                });
                const expected = 'Smith.John.William';
                if (result === expected) {
                    console.log('✓ Test 19 PASS: Name placeholders');
                    console.log(`  NAME template → Output: "${result}"`);
                    passCount++;
                } else {
                    console.error(`✗ Test 19 FAIL: Expected "${expected}", got "${result}"`);
                    failCount++;
                }
            } catch (e) {
                console.error('✗ Test 19 ERROR:', e.message);
                failCount++;
            }

            // Test 20: Complex template with modifiers
            try {
                const result = processSubTemplate('{SURNAME:upper}.{GIVEN:lower}.{MIDDLE:title}', {
                    surname: 'smith',
                    given: 'JOHN',
                    middle: 'william henry'
                });
                const expected = 'SMITH.john.William Henry';
                if (result === expected) {
                    console.log('✓ Test 20 PASS: Complex template with multiple modifiers');
                    console.log(`  Multi-modifier template → Output: "${result}"`);
                    passCount++;
                } else {
                    console.error(`✗ Test 20 FAIL: Expected "${expected}", got "${result}"`);
                    failCount++;
                }
            } catch (e) {
                console.error('✗ Test 20 ERROR:', e.message);
                failCount++;
            }

            // Test 21: Case-insensitive modifier matching - :UPPER (AC #6)
            try {
                const result = processSubTemplate('{GIVEN:UPPER}', { given: 'john' });
                const expected = 'JOHN';
                if (result === expected) {
                    console.log('✓ Test 21 PASS: Case-insensitive modifier :UPPER');
                    console.log(`  Input: {GIVEN:UPPER} → Output: "${result}"`);
                    passCount++;
                } else {
                    console.error(`✗ Test 21 FAIL: Expected "${expected}", got "${result}"`);
                    failCount++;
                }
            } catch (e) {
                console.error('✗ Test 21 ERROR:', e.message);
                failCount++;
            }

            // Test 22: Case-insensitive modifier matching - :Upper (AC #6)
            try {
                const result = processSubTemplate('{GIVEN:Upper}', { given: 'john' });
                const expected = 'JOHN';
                if (result === expected) {
                    console.log('✓ Test 22 PASS: Case-insensitive modifier :Upper');
                    console.log(`  Input: {GIVEN:Upper} → Output: "${result}"`);
                    passCount++;
                } else {
                    console.error(`✗ Test 22 FAIL: Expected "${expected}", got "${result}"`);
                    failCount++;
                }
            } catch (e) {
                console.error('✗ Test 22 ERROR:', e.message);
                failCount++;
            }

            // Test 23: Case-insensitive modifier matching - :LOWER (AC #6)
            try {
                const result = processSubTemplate('{SURNAME:LOWER}', { surname: 'SMITH' });
                const expected = 'smith';
                if (result === expected) {
                    console.log('✓ Test 23 PASS: Case-insensitive modifier :LOWER');
                    console.log(`  Input: {SURNAME:LOWER} → Output: "${result}"`);
                    passCount++;
                } else {
                    console.error(`✗ Test 23 FAIL: Expected "${expected}", got "${result}"`);
                    failCount++;
                }
            } catch (e) {
                console.error('✗ Test 23 ERROR:', e.message);
                failCount++;
            }

            // Test 24: Case-insensitive modifier matching - :TITLE (AC #6)
            try {
                const result = processSubTemplate('{GIVEN:TITLE}', { given: 'john william' });
                const expected = 'John William';
                if (result === expected) {
                    console.log('✓ Test 24 PASS: Case-insensitive modifier :TITLE');
                    console.log(`  Input: {GIVEN:TITLE} → Output: "${result}"`);
                    passCount++;
                } else {
                    console.error(`✗ Test 24 FAIL: Expected "${expected}", got "${result}"`);
                    failCount++;
                }
            } catch (e) {
                console.error('✗ Test 24 ERROR:', e.message);
                failCount++;
            }

            // Test 25: Case-insensitive modifier matching - :ABBREV (AC #6)
            try {
                const result = processSubTemplate('{GIVEN:ABBREV}', { given: 'john' });
                const expected = 'J';
                if (result === expected) {
                    console.log('✓ Test 25 PASS: Case-insensitive modifier :ABBREV');
                    console.log(`  Input: {GIVEN:ABBREV} → Output: "${result}"`);
                    passCount++;
                } else {
                    console.error(`✗ Test 25 FAIL: Expected "${expected}", got "${result}"`);
                    failCount++;
                }
            } catch (e) {
                console.error('✗ Test 25 ERROR:', e.message);
                failCount++;
            }

            // Test 26: Invalid modifier handling (AC #7) - console.warn() should be called
            try {
                const originalWarn = console.warn;
                let warnCalled = false;
                let warnMessage = '';
                console.warn = function(msg) {
                    warnCalled = true;
                    warnMessage = msg;
                    originalWarn.apply(console, arguments);
                };

                const result = processSubTemplate('{NAME:invalid}', { name: 'Smith' });

                console.warn = originalWarn;

                // Should return original value and log warning
                if (result === 'Smith' && warnCalled && warnMessage.includes('Unknown modifier')) {
                    console.log('✓ Test 26 PASS: Invalid modifier handling');
                    console.log(`  Invalid modifier :invalid → Original value returned: "${result}"`);
                    console.log(`  Warning logged: "${warnMessage}"`);
                    passCount++;
                } else {
                    console.error(`✗ Test 26 FAIL: Invalid modifier not handled correctly (result: "${result}", warnCalled: ${warnCalled})`);
                    failCount++;
                }
            } catch (e) {
                console.error('✗ Test 26 ERROR:', e.message);
                failCount++;
            }

            // Test 27: Multiple modifier chain - only last modifier applied (AC #8)
            try {
                const result = processSubTemplate('{GIVEN:upper:lower}', { given: 'john' });
                const expected = 'john';
                if (result === expected) {
                    console.log('✓ Test 27 PASS: Multiple modifier chain - last modifier applied');
                    console.log(`  Input: {GIVEN:upper:lower} → Only :lower applied → Output: "${result}"`);
                    passCount++;
                } else {
                    console.error(`✗ Test 27 FAIL: Expected "${expected}", got "${result}"`);
                    failCount++;
                }
            } catch (e) {
                console.error('✗ Test 27 ERROR:', e.message);
                failCount++;
            }

            // Test 28: Multiple modifier chain - 3 modifiers, last applied (AC #8)
            try {
                const result = processSubTemplate('{GIVEN:upper:lower:title}', { given: 'john smith' });
                const expected = 'John Smith';
                if (result === expected) {
                    console.log('✓ Test 28 PASS: Multiple modifier chain (3 modifiers) - last applied');
                    console.log(`  Input: {GIVEN:upper:lower:title} → Only :title applied → Output: "${result}"`);
                    passCount++;
                } else {
                    console.error(`✗ Test 28 FAIL: Expected "${expected}", got "${result}"`);
                    failCount++;
                }
            } catch (e) {
                console.error('✗ Test 28 ERROR:', e.message);
                failCount++;
            }

            // Test 29: Edge case - modifier with empty string value (AC #7)
            try {
                const result = processSubTemplate('{GIVEN:upper}', { given: '' });
                const expected = 'x';
                if (result === expected) {
                    console.log('✓ Test 29 PASS: Modifier with empty string (uses missing value handler)');
                    console.log(`  Empty given="" → falls back to missing value "x"`);
                    passCount++;
                } else {
                    console.error(`✗ Test 29 FAIL: Expected "${expected}", got "${result}"`);
                    failCount++;
                }
            } catch (e) {
                console.error('✗ Test 29 ERROR:', e.message);
                failCount++;
            }

            // Test 30: Edge case - modifier with special characters (AC #7)
            try {
                const result = processSubTemplate('{GIVEN:title}', { given: "o'brien" });
                const expected = "O'brien";
                if (result === expected) {
                    console.log('✓ Test 30 PASS: Modifier with special characters (apostrophe)');
                    console.log(`  Input: "o'brien" with :title → Output: "${result}"`);
                    passCount++;
                } else {
                    console.error(`✗ Test 30 FAIL: Expected "${expected}", got "${result}"`);
                    failCount++;
                }
            } catch (e) {
                console.error('✗ Test 30 ERROR:', e.message);
                failCount++;
            }

            // Test 31: Edge case - modifier with numbers in value (AC #7)
            try {
                const result = processSubTemplate('{GIVEN:title}', { given: 'john 123' });
                const expected = 'John 123';
                if (result === expected) {
                    console.log('✓ Test 31 PASS: Modifier with numbers in value');
                    console.log(`  Input: "john 123" with :title → Output: "${result}"`);
                    passCount++;
                } else {
                    console.error(`✗ Test 31 FAIL: Expected "${expected}", got "${result}"`);
                    failCount++;
                }
            } catch (e) {
                console.error('✗ Test 31 ERROR:', e.message);
                failCount++;
            }

            // Test 32: Modifier with single letter word (AC #5)
            try {
                const result = processSubTemplate('{GIVEN:abbrev}', { given: 'a' });
                const expected = 'A';
                if (result === expected) {
                    console.log('✓ Test 32 PASS: Abbrev modifier with single character');
                    console.log(`  Input: "a" with :abbrev → Output: "${result}"`);
                    passCount++;
                } else {
                    console.error(`✗ Test 32 FAIL: Expected "${expected}", got "${result}"`);
                    failCount++;
                }
            } catch (e) {
                console.error('✗ Test 32 ERROR:', e.message);
                failCount++;
            }

            // Summary
            console.log('\n' + '='.repeat(50));
            console.log(`TEST RESULTS: ${passCount} passed, ${failCount} failed`);
            console.log(`Pass rate: ${(passCount / (passCount + failCount) * 100).toFixed(1)}%`);
            console.log('='.repeat(50) + '\n');

            return { passCount, failCount, total: passCount + failCount };
        }

        // Initialize
        loadSettings(); // Load saved settings from localStorage (Story 2)
        initializeSuggestionTriggers();
        updatePlaceFormatUI();
        updateTemplatePreview(); // Show template preview immediately on load
        generateFilename();

        // Run tests for Story 1.1 (processSubTemplate function)
        const testResults = runProcessSubTemplateTests();

        // Initialize Bootstrap tooltips for help icons
        const tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]'));
        tooltipTriggerList.map(function (tooltipTriggerEl) {
            return new bootstrap.Tooltip(tooltipTriggerEl, {
                placement: 'top',
                delay: { show: 300, hide: 0 }
            });
        });
        
        // Debug: Check if addPersonBtn element exists
        console.log('addPersonBtn element:', elements.addPersonBtn);
        console.log('addPersonBtn exists:', !!elements.addPersonBtn);
        
        // Add a direct test click handler
        if (elements.addPersonBtn) {
            console.log('Adding test click handler to addPersonBtn');
        } else {
            console.error('addPersonBtn element not found!');
        }
    </script>
</body>
</html>